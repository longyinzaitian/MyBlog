/*
Navicat MySQL Data Transfer

Source Server         : OverrideRe
Source Server Version : 80000
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 80000
File Encoding         : 65001

Date: 2017-03-19 11:51:50
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` varchar(255) NOT NULL,
  `article_title` varchar(255) DEFAULT NULL,
  `article_summary` varchar(255) DEFAULT NULL,
  `article_content` text,
  `comment_num` int(11) DEFAULT NULL,
  `article_date` datetime DEFAULT NULL,
  `author_id` varchar(255) DEFAULT NULL,
  `readnum` int(11) DEFAULT NULL,
  `tag` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `classification` int(11) DEFAULT NULL,
  `collector_id` varchar(255) DEFAULT NULL,
  `state` int(11) DEFAULT NULL,
  PRIMARY KEY (`article_id`),
  KEY `author` (`author_id`),
  KEY `collector` (`collector_id`),
  CONSTRAINT `author` FOREIGN KEY (`author_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `collector` FOREIGN KEY (`collector_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('402881f25a82814c015a83038b070002', 'Filter和Listener', '[TOC]#Filter过滤器Filter的简介对资源的访问进行过滤，相当于小区的保安，进去要检查，出去还要检查。Filter的使用编写一个类，继承并实现javax.servlet.Filter。```javapackagecom.jyh.filter;importjava.io.IOException;importjavax.servlet.Filter;importjavax.servlet.', '[TOC]\n#**Filter过滤器**\n **Filter的简介**\n	对资源的访问进行过滤，相当于小区的保安，进去要检查，出去还要检查。\n\n **Filter的使用**\n\n1. 编写一个类，继承并实现javax.servlet.Filter。\n\n	```java\npackage com.jyh.filter;\n		import java.io.IOException;\n		import javax.servlet.Filter;\n		import javax.servlet.FilterChain;\n		import javax.servlet.FilterConfig;\n		import javax.servlet.ServletException;\n		import javax.servlet.ServletRequest;\n		import javax.servlet.ServletResponse;\n		\n		\n		public class FilterDemo1 implements Filter {\n		\n			private FilterConfig filterConfig;\n			\n			public FilterDemo1(){\n				System.out.println(\"实例化了\");\n			}\n			\n			//初始化\n			@Override\n			public void init(FilterConfig filterConfig) throws ServletException {\n				//通过这个获取过滤器在web.xml里面的配置信息\n				this.filterConfig = filterConfig;\n				System.out.println(\"过滤器初始化了\");\n			}\n		\n			//执行\n			@Override\n			public void doFilter(ServletRequest req, ServletResponse res,\n					FilterChain chain) throws IOException, ServletException {\n		\n				//获取在web.xml中本过滤器配置的名为encoding的参数\n				String encoding = filterConfig.getInitParameter(\"encoding\");\n				if(encoding == null){\n					encoding = \"UTF-8\";\n				}\n				//设置编码格式\n				req.setCharacterEncoding(encoding);\n				res.setContentType(\"text/html;charset=\" + encoding);\n				System.out.println(\"过滤前\");\n				//放行\n				chain.doFilter(req, res);\n				System.out.println(\"过滤后\");\n			}\n		\n			//销毁\n			@Override\n			public void destroy() {\n				System.out.println(\"过滤器销毁了\");\n			}\n		\n		}\n	```\n\n2.  在web.xml中配置Filter\n\n	```xml\n	<filter>\n	    <filter-name>FilterDemo1</filter-name>\n	    <filter-class>com.jyh.filter.FilterDemo1</filter-class>\n	    <!-- 配置参数 -->\n	    <init-param>\n	    	<param-name>encoding</param-name>\n	    	<param-value>UTF-8</param-value>\n	    </init-param>\n	  </filter>\n	  <filter-mapping>\n	    <filter-name>FilterDemo1</filter-name>\n	    <url-pattern>/*</url-pattern>\n	  </filter-mapping>\n	```\n过滤器是用来对访问进去过滤的，所以需要在请求前做什么和请求之后做什么都可以用过滤器来做，例如编码的设置，自动登录等。串联过滤器什么的听着就知道是什么情况了。\n\n#Listener监听器\n\n- 编写一个类继承实现以下监听器接口。\n\n1. 监听ServletContext、HttpSession、ServletRequest对象的创建和销毁的监听器\n\n	ServletContextListener:\n	HttpSessionListener:\n	SerlvetRequestListener:\n\n2. 监听ServletContext、HttpSession、ServletRequest属性(attributes)变化的监听器\n\n	ServletContextAttributeListener\n	HttpSessionAttributeListener\n	SerlvetRequestAttributeListener\n\n3. 感知型监听器：不需要注册。\n\n	HttpSessionBindingListener：实现该接口的类的实例，能够感知自己何时被放到了HttpSession域范围中，和何时从HttpSession域范围中删除。\n	\n	HttpSessionActivationListener：实现该接口的类的实例，能够感知自己何时随着HttpSession钝化和激活。\n\n- 在web.xml配置一下\n\n	```xml\n	  <listener>\n		  <!-- 指向自己缩写的监听器类 -->\n	  	<listener-class>com.jyh.listener.MyContextListener</listener-class>\n	  </listener>\n	```', null, '2017-03-04 02:43:10', '111', '170', 'JDBC,java', '0', '3', null, '1');
INSERT INTO `article` VALUES ('402881f25a82814c015a8330bd820007', 'JavaWeb学习笔记5---JDBC学习之一', '[TOC]\n# **JDBC学习1**\n## **JDBC简介**\nJDBC：Java DataBase Connectivity，是SUN推出的操作数据库的规范。\nJDBC和数据库驱动：规范和实现的关系。\nJDBC：JDK中。java.sql.*;javax.sql.*;\n驱动：去数据库厂商的网站下载\n\n## **JDBC开发步骤**\n0. 搭建开发环境：把数据库驱动的jar包加入到构建路径中。', '[TOC]\n# **JDBC学习1**\n## **JDBC简介**\nJDBC：Java DataBase Connectivity，是SUN推出的操作数据库的规范。\nJDBC和数据库驱动：规范和实现的关系。\nJDBC：JDK中。java.sql.*;javax.sql.*;\n驱动：去数据库厂商的网站下载\n\n## **JDBC开发步骤**\n0. 搭建开发环境：把数据库驱动的jar包加入到构建路径中。\n1. 注册驱动\n2. 获取与数据库的链接\n3. 创建代表SQL语句的对象\n4. 执行SQL语句(如果是查询语句：返回结果集。)\n5. 遍历结果集里的内容\n6. 释放资源\n代码：\n\n```java\npackage com.jyh.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.jyh.domain.User;\n\npublic class JDBCConnect {\n\n	public static void main(String[] args) throws Exception{\n		\n		//1.注册驱动\n		//DriverManager.registerDriver(new Driver());\n		\n		//2.获取链接\n		//Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/database1\", \"root\", \"ying1995520***\");\n		\n		//3.创建代表sql语句的对象\n		Statement st = conn.createStatement();\n		\n		//4.执行SQL语句(如果是查询语句则返回结果集)\n		ResultSet rs = st.executeQuery(\"select * from user\");\n		\n		//5.遍历返回的结果集里面的内容\n		List<User> list = new ArrayList<>();\n		while(rs.next()){\n			User user = new User();\n			user.setId(rs.getString(\"id\"));\n			user.setName(rs.getString(\"name\"));\n			user.setPassword(rs.getString(\"password\"));\n			user.setEmail(rs.getString(\"email\"));\n			user.setBirthday(rs.getDate(\"birthday\"));\n			list.add(user);\n		}\n		System.out.println(list.size());\n		\n		//6.释放资源\n		rs.close();\n		st.close();\n		conn.close();\n	}\n}\n\n```\n## **JDBC规范中常用的接口和类**\n\n### **DriverManager**\n\n**作用：**\n\n**1. 注册驱动**\n 1. 方式一：DriverManager.registerDriver(new com.mysql.jdbc.Driver());\n缺点：\n  1. 严重依赖具体的数据库驱动\n  2. 导致数据驱动注册2遍\n 2. 方式二：（推荐）\n\n**2. 获取与数据库的链接**\n 1. 方式一：\n Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/day15\",\n \"root\", \"sorry\");\nString url:JDBC与数据库厂商的协议。具体参考数据库的文档。\nOracle：jdbc:oracle:thin:@localhost:1521:orcl 瘦客户端链接方式\n jdbc:oracle:client:@localhost:1521:orcl 客户端链接方式，高效\n 2. 方式二：\n Connection conn = DriverManager.getConnection(\"jdbc:mysql:///day15?user=root&password=sorry\");\n \n### **Connection**\n\n作用：所有与数据库的交互都是基于链接的。\n\n### **Statement**\n\n**作用：**代表SQL语句对象\n\n**常用方法：**\n- ResultSet executeQuery(String sql):执行查询，返回结果集。\n- int executeUpdate(String sql):执行DML语句。返回的是SQL语句影响到的记录条数。\n- boolean execute(String sql):执行任何的SQL语句。返回值不代表成功与否。如果执行的语句有结果集，返回true，否则返回false。\n\n### **ResultSet**\n\n**作用：**封装了结果集\n`rs.getString(\"id\")` 根据列名获取值\n`rs.getString(1)` 根据列好获取值，从1开始\n\n**数据库类型和Java类型的对应关系：**\n\n| SQL类型 | JDBC对应方法 | 返回类型 |\n| ------------- |-------------| -----|\n| BIT(1) bit(n) | getBolean() getBytes() | Boolean byte[] |\n| TINYINT | getByte() | Byte |\n| SMALLINT | getShort() | Short |\n| Int | getInt() | Int |\n| BIGINT | getLong() | Long |\n| CHAR,VARCHAR,LONGVARCHAR | getString() | String |\n| Text(clob) blob| getClob() getBlob() | Clob Blob |\n| DATE | getDate() | java.sql.Date |\n| TIME | getTime() | java.sql.Time |\n| TIMESTAMP | getTimestamp() | java.sql.Timestamp |\n\n---------------------------------------------------------------------------------\n**常用的方法：**\nboolean next():向下移动。返回有没有记录\nboolean provious():向上移动。返回有没有记录\nboolean absolute(int row):定位。返回有没有记录。看第2条，写2.\nvoid beforeFirst():移动到第一条记录的前面。默认位置\nvoid afterLast():移动到最后一条记录的后面。\n\n## **抽取JDBC的工具类**\n```java\npackage com.jyh.jdbc;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n\n\npublic class JdbcUtil {\n	\n	private static String driverClass;\n	private static String url;\n	private static String user;\n	private static String password;\n	\n	static{\n		try {\n			//获取配置文件路径\n			String path = JdbcUtil.class.getClassLoader().getResource(\"jdbcConfig.properties\").getPath();\n			//读取配置文件\n			InputStream is = new FileInputStream(path);\n			//将配置文件中的内容加载进Properties中\n			Properties ps = new Properties();\n			ps.load(is);\n			is.close();\n			//获取配置属性值\n			driverClass = ps.getProperty(\"driverClass\");\n			url = ps.getProperty(\"url\");\n			user = ps.getProperty(\"user\");\n			password = ps.getProperty(\"password\");\n			//注册数据库驱动\n			Class.forName(driverClass);\n		} catch (Exception e) {\n			throw new ExceptionInInitializerError();\n		}\n	}\n\n	//获取链接\n	public static Connection getConnection() throws Exception{\n		Connection conn = DriverManager.getConnection(url, user, password);\n		return conn;\n	}\n	\n	//关闭链接\n	public static void release(ResultSet rs,Statement st,Connection conn){\n		if(st != null){\n			try {\n				st.close();\n			} catch (SQLException e) {\n				e.printStackTrace();\n			}\n			st = null;\n		}\n		if(rs != null){\n			try {\n				rs.close();\n			} catch (SQLException e) {\n				e.printStackTrace();\n			}\n			rs = null;\n		}\n		if(conn != null){\n			try {\n				conn.close();\n			} catch (SQLException e) {\n				e.printStackTrace();\n			}\n			conn = null;\n		}\n	}\n}\n```\n## **PreparedStatement接口**\n原则：能用PreparedStatement就不要使用Statement\n优点：\n- 参数使用占位符（？）替代\n- 预编SQL语句，执行效率高\n- 不存在SQL注入问题\n## **批处理**\n\n```java\n//如果批处理执行的语句不相同，最好使用Statement\n	public void test1(){\n		Connection conn = null;\n		Statement stmt =  null;\n		try{\n			conn = JdbcUtil.getConnection();\n			stmt = conn.createStatement();//内部有一个List，就是sql语句的缓存\n			\n			String sql1 = \"insert into t1 (id,name) values(1,\'aa1\')\";\n			String sql2 = \"insert into t1 (id,name) values(2,\'aa2\')\";\n			String sql3 = \"delete from t1 where id=1\";\n			\n			stmt.addBatch(sql1);\n			stmt.addBatch(sql2);\n			stmt.addBatch(sql3);\n			\n			int [] ii = stmt.executeBatch();//批处理.每条语句影响的行数\n			\n			for(int i:ii)\n				System.out.println(i);\n		}catch(Exception e){\n			e.printStackTrace();\n		}finally{\n			JdbcUtil.release(null, stmt, conn);\n		}\n	}\n\n//很多时候：语句相同，只是参数不同\n	//PreparedStatement\n	//插入10条记录\n	@Test\n	public void test2(){\n		Connection conn = null;\n		PreparedStatement stmt =  null;\n		try{\n			conn = JdbcUtil.getConnection();\n			stmt = conn.prepareStatement(\"insert into t1 (id,name) values(?,?)\");\n			\n			for(int i=0;i<10;i++){\n				stmt.setInt(1, i+1);\n				stmt.setString(2, \"aa\"+(i+1));\n				stmt.addBatch();//向缓存中加的参数\n			}\n			\n			int [] ii = stmt.executeBatch();//批处理.每条语句影响的行数\n			\n			for(int i:ii)\n				System.out.println(i);\n		}catch(Exception e){\n			e.printStackTrace();\n		}finally{\n			JdbcUtil.release(null, stmt, conn);\n		}\n	}\n```\n## **LOB（CLOB、BLOB）的存取**\n\n1. LOB：Large Object。\nCLOB：character Large Object。大文本。\nBLOB：Binary Large Object。图片、视频、声音等。\n2. MySQL支持的LOB的类型。可变长度类型。\nTINYBLOB, TINYTEXT 256B\nBLOB, TEXT 64K\nMEDIUMBLOB, MEDIUMTEXT 16M\nLONGBLOB, LONGTEXT 4G\n\n```java\npackage com.jyh.lob;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\nimport org.junit.Test;\n\nimport com.jyh.jdbc.JdbcUtil;\n\npublic class LobTest {\n\n	/**\n	 * create table t1(\n	 * 	id int primary key,\n	 *  content longtext\n	 * )\n	 * @throws Exception \n	 */\n	//数据库文本写入\n	@Test\n	public void testTextWrite() throws Exception{\n		Connection conn = JdbcUtil.getConnection();\n		PreparedStatement st = conn.prepareStatement(\"insert into t1(id,content) values(?,?)\");\n		st.setInt(1, 1);\n		File file = new File(\"src/clob.txt\");\n		Reader reader = new FileReader(file);\n		//setCharacterStream(int, Reader, long)MySQL没实现，因为MySQL最大存储小于long类型\n		st.setCharacterStream(2, reader, (int)file.length());\n		st.executeUpdate();\n		JdbcUtil.release(null, st, conn);\n	}\n\n	//数据库文本读取\n	@Test\n	public void testTextRead() throws Exception{\n		Connection conn = JdbcUtil.getConnection();\n		PreparedStatement st = conn.prepareStatement(\"select content from t1 where id = ?\");\n		st.setInt(1, 1);\n		ResultSet rs = st.executeQuery();\n		if(rs.next()){\n			Reader reader = rs.getCharacterStream(\"content\");\n			Writer wr = new FileWriter(\"d:/tt.txt\");\n			char[] c = new char[1024];\n			int len = -1;\n			while((len = reader.read(c)) != -1){\n				wr.write(c, 0, len);\n			}\n			wr.flush();\n			reader.close();\n			wr.close();\n		}\n		JdbcUtil.release(rs, st, conn);\n	}\n	/**\n	 * create table t2(\n	 * 	id int primary key,\n	 *  content longblob\n	 * )\n	 * @throws Exception \n	 */\n	//二进制数据写入（图片、音频、视频等）\n	@Test\n	public void testBinaryWrite() throws Exception{\n		Connection conn = JdbcUtil.getConnection();\n		PreparedStatement st = conn.prepareStatement(\"insert into t2(id,content) values(?,?)\");\n		st.setInt(1, 1);\n		InputStream in = new FileInputStream(\"src/1044490.jpg\");\n		st.setBinaryStream(2, in , in.available());\n		st.executeUpdate();\n		JdbcUtil.release(null, st, conn);\n	}\n	\n	//二进制数据读取（图片、音频、视频等）\n	@Test\n	public void testBinaryRead() throws Exception{\n		Connection conn = JdbcUtil.getConnection();\n		PreparedStatement st = conn.prepareStatement(\"select content from t2 where id = ?\");\n		st.setInt(1, 1);\n		ResultSet rs = st.executeQuery();\n		if(rs.next()){\n			InputStream in = rs.getBinaryStream(\"content\");\n			OutputStream out = new FileOutputStream(\"d:/1.jpg\");\n			byte[] b = new byte[1024];\n			int len = -1;\n			while((len = in.read(b)) != -1){\n				out.write(b, 0, len);\n			}\n			out.flush();\n			in.close();\n			out.close();\n		}\n		JdbcUtil.release(rs, st, conn);\n	}\n}\n```\n\n## **事务的入门**\n\n### **数据库的事务控制**\nstart transaction:开启事务\nrollback:回滚事务\ncommit:提交事务\n\n### **JDBC控制事务**\n```java\npackage com.jyh.transaction;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Savepoint;\n\nimport org.junit.Test;\n\nimport com.jyh.jdbc.JdbcUtil;\n\n\npublic class TransactionDemo {\n	\n	@SuppressWarnings(\"resource\")\n	@Test\n	public void demo1(){\n		Connection conn = null;\n		PreparedStatement st = null;\n		ResultSet rs = null;\n		Savepoint sp = null;\n		try{\n			conn = JdbcUtil.getConnection();\n			conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);//在事务之前设置事务的隔离级别\n			conn.setAutoCommit(false);//事务起始点\n			st = conn.prepareStatement(\"update account set salary=salary+100 where id = 1\");\n			st.executeUpdate();\n			st = conn.prepareStatement(\"update account set salary=salary-100 where id = 2\");\n			st.executeUpdate();\n			\n			sp = conn.setSavepoint();//回滚点\n			\n			st = conn.prepareStatement(\"update account set salary=salary+100 where id = 1\");\n			st.executeUpdate();\n			\n			@SuppressWarnings(\"unused\")\n			int i = 1/0;\n			\n			st = conn.prepareStatement(\"update account set salary=salary-100 where id = 3\");\n			st.executeUpdate();\n		}catch(Exception e){\n			if(conn != null){\n				try {\n					conn.rollback(sp);//回滚到回滚点\n				} catch (SQLException e1) {\n					e1.printStackTrace();\n				}\n			}\n		}finally{\n			if(conn != null){\n				try {\n					conn.commit();//提交事务\n				} catch (SQLException e) {\n					e.printStackTrace();\n				}\n			}\n			JdbcUtil.release(rs, st, conn);\n		}\n	}\n}\n```\n\n## **事务的特性**\n\n### **事务的特性**\n1. 原子性：指处于同一个事务中的多条语句是不可分割的，要么全部成功，要么全部失败。\n2. 一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态，相当于守恒。比如，转账，转账前两个账户余额之和为2k，转账之后也应该是2K。\n3. 隔离性：指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰\n4. 持久性：事务一旦提交，就应该被永久保存起来。\n\n### **事务隔离性专题**\n**如果不考虑事务的隔离性，会出现以下问题：**\n1. 脏读：指一个线程中的事务读取到了另外一个线程中未提交的数据。\n2. 不可重复读：指一个线程中的事务读取到了另外一个线程中提交的update的数据。\n3. 虚读：指一个线程中的事务读取到了另外一个线程中提交的insert的数据。\n\n**隔离级别：**\n1：READ UNCOMMITTED:脏读、不可重复读、虚读都有可能发生。\n2：READ COMMITTED:防止脏读的发生，不可重复读、虚读都有可能发生。\n4：REPEATABLE READ:防止脏读、不可重复读的发生，虚读有可能发生。\n8：SERIALIZABLE:防止脏读、不可重复读、虚读的发生。\n级别越高，数据越安全，但性能越低。\n\n1. 脏读：事务提交之前发生。\n    a事务还没提交，b事务开始，然后获取的数据是a事务还没提交的数据。\n    READ COMMITTED就是防止脏读发生\n2. 不可重复读：事务提交之后发生。\n   a拿着工资卡去消费(a事务开启)，系统读取到卡里确实有5000元，而此时他的老婆也正好在网上转账，把a工资卡的5000元转到另一账户(b事务开启)，并在a之前提交了事务(b事务提交)，当a扣款时，系统检查到a的工资卡已经没有钱，扣款失败，a十分纳闷，明明卡里有钱，为何......\n   总结就是a事务开始--->b事务开始--->b事务结束--->a事务结束\n   导致a得到的数据前后不一致\n   REPEATABLE READ解决不可重复读，相当于在操作某条数据的时候就已经锁定了该条数据，使得别人无法修改。\n3. 虚读：事务提交之后发生。\n    虚读其实跟不可重复读差不多，也是前后数据不一致，不过不是某一条，而是当前表格数据发生变化，也就是增加了一条数据。a事务开始读的时候是5条，然后b添加了一条就关闭了事务，a这时候还没关闭，再读取的时候就多了一条。\n    SERIALIZABLE是最高级别，防止了脏读，不可重复读和虚读，在我理解就相当于锁定了整张表，在某一个事务操作该表的时候，其它任何事务都不能对该表进行操作。\n\n**MySQL控制事务的隔离级别：**\n查看当前事务的隔离级别：SELECT @@tx_isolation;\n更改事务的隔离级别：（注意：一定要在开启事务之前设定）\nSET transaction isolation level 四个级别之一(单词);\n\n**JDBC中如何控制事务的隔离级别：**\n前提：在开启事务之前设置隔离级别。\n```javaconn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);//在事务之前设置事务的隔离级别```\n\n![事务的隔离级别表示](http://img.blog.csdn.net/20161220214710869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n        ', null, '2017-03-01 01:00:00', '111', '36', 'java,jdbc', '0', '3', null, '1');
INSERT INTO `article` VALUES ('402881f25a82814c015a8334a05c000e', '数据库链接池', '\n\n### **DBUtils**\n1. 导包\n	commons-dbutils-xxx.jar包和commons-pool-xxx.jar包，xxx是版本号。\n2. 使用\n	```java\n	package com.jyh.dbutil;\n\n	import java.sql.SQLException;\n	import java.util.Date;\n	import java.util.List;', '[toc]\r\n# **数据库链接池**\r\n## **数据库链接池的简介**\r\n### **数据库链接池是什么**\r\n数据库链接-池，顾名思义就是存放数据库链接的池子。\r\n### **数据库链接池的作用**\r\n存放数据库链接供人获取调用\r\n### **数据库链接池的好处**\r\n不需要每个链接都需要自己创建，只在刚开始初始化的时候创建一定数量的链接，节省了资源时间，效率高，现拿现用。\r\n### **模拟数据库链接池**\r\n```java\r\npackage com.jyh.jdbc.pool;\r\n\r\nimport java.sql.Connection;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport com.jyh.jdbc.JdbcUtil;\r\n\r\n\r\npublic class SimpleConnectionPool {\r\n\r\n	private static List<Connection> cl = Collections.synchronizedList(new ArrayList<Connection>());\r\n	\r\n	static{\r\n		for(int i = 0;i < 10; i ++){\r\n			//初始化连接池向连接池中添加一定数量的链接\r\n			cl.add(JdbcUtil.getConnection());//该链接都是从已写好的jdbc工具类中获取的\r\n		}\r\n	}\r\n	\r\n	public static Connection getConnection(){\r\n		if(cl.size() <= 0){\r\n			///如果链接池中没有链接了则可以再创建若干个链接放入池中\r\n			for(int i = 0;i < 10; i ++){\r\n				cl.add(JdbcUtil.getConnection());\r\n			}\r\n		}\r\n		//返回第一个链接并从链接池中删除\r\n		return cl.remove(0);\r\n	}\r\n	\r\n	public static void release(Connection conn){\r\n		cl.add(conn);\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		//从链接池中获取链接\r\n		Connection conn = SimpleConnectionPool.getConnection();\r\n		//一系列操作\r\n		System.out.println(conn.getClass().getName());\r\n		//将链接放回链接池,这里不能调用.close()方法，而是自己定义了一个方法\r\n		SimpleConnectionPool.release(conn);\r\n	}\r\n}\r\n```\r\n### **需要解决的问题**\r\n#### **发现的问题**\r\n从池中获取一个链接后，用户用完自觉的调用conn.close()方法。应该达到的效果：不要关闭，而应该还回池中，而com.mysql.jdbc.Connection.close():只会关闭\r\n#### **解决方法**\r\n##### **1. 静态代理还是装饰设计模式？**\r\n我们需要将该方法变成返还到池中，然后我们立即想到了可以重写该方法啊，等我们准备继承该类的时候发现，无法继承，所以这个方法不行。\r\n我们要用这个类是这类里面有我们需要的方法，所以我们自己建一个跟它一样的类不就行了么，继承同一个接口，然后方法实现也编写得一样，只把我们需要改变的方法改成我们需要的样子。想要方法实现是一样的，那么直接调用以前的不就行了了，所以需要在新建的类中new一个com.mysql.jdbc.Connection实例，不需要改变的方法直接调用实例的方法，需要改变的方法自己重写。然后又想到了，如果直接在新类中new一个com.mysql.jdbc.Connection实例就定死了，万一要换数据库呢，别的数据库可不是这个类实现java.sql.Connection接口的。所以不能定死，要从外面传过来。于是我们可以在新的类里面定义一个java.sql.Connection类型的变量，反正无论什么数据库驱动都是要实现这个类的，该变量在新类初始化的时候由外面传一个数据库驱动实例进来，通过构造函数进行赋值初始化，这样就好了吧。但是，不要忘了我们要改写的方法是什么样的---将close()方法改写成放入链接池，所以链接池的实例不能缺少，于是再定义一个链接池变量，也在新类初始化的时候赋值初始化。代码如下：\r\n```java\r\npackage com.jyh.jdbc.pool;\r\n\r\nimport java.util.List;\r\nimport java.sql.Array;\r\nimport java.sql.Blob;\r\nimport java.sql.CallableStatement;\r\nimport java.sql.Clob;\r\nimport java.sql.Connection;\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.NClob;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.SQLClientInfoException;\r\nimport java.sql.SQLException;\r\nimport java.sql.SQLWarning;\r\nimport java.sql.SQLXML;\r\nimport java.sql.Savepoint;\r\nimport java.sql.Statement;\r\nimport java.sql.Struct;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\nimport java.util.concurrent.Executor;\r\n\r\n\r\npublic class MyConnection implements Connection {\r\n\r\n	private Connection conn;//需要初始化的数据库驱动\r\n	private List<Connection> cl;//需要初始化的链接池\r\n\r\n	\r\n	public MyConnection(Connection conn, List<Connection> cl) {\r\n		this.conn = conn;\r\n		this.cl = cl;\r\n	}\r\n\r\n	//需要改写的close方法\r\n	public void close() throws SQLException {\r\n		System.out.println(\"这里是MyConnection的close方法\");\r\n		cl.add(conn);\r\n	}\r\n	\r\n	//其它不需要改写的方法直接调用传过来的实例里面的方法即可\r\n	public <T> T unwrap(Class<T> iface) throws SQLException {\r\n		return conn.unwrap(iface);\r\n	}\r\n\r\n	public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n		return conn.isWrapperFor(iface);\r\n	}\r\n\r\n	public Statement createStatement() throws SQLException {\r\n		return conn.createStatement();\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql) throws SQLException {\r\n		return conn.prepareStatement(sql);\r\n	}\r\n\r\n	public CallableStatement prepareCall(String sql) throws SQLException {\r\n		return conn.prepareCall(sql);\r\n	}\r\n\r\n	public String nativeSQL(String sql) throws SQLException {\r\n		return conn.nativeSQL(sql);\r\n	}\r\n\r\n	public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n		conn.setAutoCommit(autoCommit);\r\n	}\r\n\r\n	public boolean getAutoCommit() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return false;\r\n	}\r\n\r\n	public void commit() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public void rollback() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public boolean isClosed() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return false;\r\n	}\r\n\r\n	public DatabaseMetaData getMetaData() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void setReadOnly(boolean readOnly) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public boolean isReadOnly() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return false;\r\n	}\r\n\r\n	public void setCatalog(String catalog) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public String getCatalog() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void setTransactionIsolation(int level) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public int getTransactionIsolation() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return 0;\r\n	}\r\n\r\n	public SQLWarning getWarnings() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void clearWarnings() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public Statement createStatement(int resultSetType, int resultSetConcurrency)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql, int resultSetType,\r\n			int resultSetConcurrency) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public CallableStatement prepareCall(String sql, int resultSetType,\r\n			int resultSetConcurrency) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public void setHoldability(int holdability) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public int getHoldability() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return 0;\r\n	}\r\n\r\n	public Savepoint setSavepoint() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Savepoint setSavepoint(String name) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void rollback(Savepoint savepoint) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public Statement createStatement(int resultSetType,\r\n			int resultSetConcurrency, int resultSetHoldability)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql, int resultSetType,\r\n			int resultSetConcurrency, int resultSetHoldability)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public CallableStatement prepareCall(String sql, int resultSetType,\r\n			int resultSetConcurrency, int resultSetHoldability)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public PreparedStatement prepareStatement(String sql, String[] columnNames)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Clob createClob() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Blob createBlob() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public NClob createNClob() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public SQLXML createSQLXML() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public boolean isValid(int timeout) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return false;\r\n	}\r\n\r\n	public void setClientInfo(String name, String value)\r\n			throws SQLClientInfoException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public void setClientInfo(Properties properties)\r\n			throws SQLClientInfoException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public String getClientInfo(String name) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Properties getClientInfo() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Array createArrayOf(String typeName, Object[] elements)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public Struct createStruct(String typeName, Object[] attributes)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void setSchema(String schema) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public String getSchema() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return null;\r\n	}\r\n\r\n	public void abort(Executor executor) throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public void setNetworkTimeout(Executor executor, int milliseconds)\r\n			throws SQLException {\r\n		// TODO Auto-generated method stub\r\n\r\n	}\r\n\r\n	public int getNetworkTimeout() throws SQLException {\r\n		// TODO Auto-generated method stub\r\n		return 0;\r\n	}\r\n\r\n}\r\n```\r\n注意：我们要面向接口编程，在创建实例对象调用方法的时候通常都是接口对象指向实现类的引用，所以接口里面没有的方法你不能添加，因为调用不了。\r\n\r\n以上到底是装饰设计模式还是静态代理模式没搞清，上网查了一下有如下几种说法：\r\n\r\n1. 有的说装饰模式就是在原有的方法基础上增强，代理模式就是修改原有的方法。\r\n	这个说法上是代理模式的功能>装饰器模式的功能\r\n2. 有的说装饰设计模式被装饰的类需要从外面传过来，所以调用者知道被装饰的是什么类，而代理模式是自己写死的，调用者不知道被代理的是什么类。\r\n	这个说法是装饰器模式的功能>静态代理的功能\r\n\r\n但是我自己是不纠结的，因为学习设计模式知识学习前人的思想，又不是学习一个个设计模式的名字，知道为什么这样设计，这样设计有什么好处，解决了什么问题就行了。\r\n##### **2. 动态代理设计模式**\r\n把上面看做代理模式好了，用上面的方法那样太麻烦了，如果代理的一个类有一百个方法，而我只需要改写一个方法，但是却要全部实现一次，所以我们看看有什么需要改进的地方。需要改进的麻烦的地方如下：\r\n1. 每个代理类都要实现一遍被代理类的方法，很麻烦，能不能省略那些实现呢？\r\n2. 想要代理一个类就要创建一个代理类太麻烦了，能不能动态的创建实例呢？\r\n动态代理就解决了这些问题。动态的创建代理类实例，只编写自己想要重写的代码\r\n\r\n代理类有什么特点呢？也就是说，如果创建了很多个代理类，这些代理类有什么共同点呢？然后观察得出如下结论：\r\n1. 需要实现与被代理类相同的接口\r\n2. 需要被代理类的实例\r\n3. 还需要改变方法的具体行为\r\n以上三点就是代理类的共同点，而动态代理模式就利用了这三个共同点\r\n实现动态代理的类与方法：\r\n\r\n```javaProxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, >InvocationHandler h)```\r\n\r\n以下为动态代理的应用：\r\n\r\n接口：\r\n```java\r\npackage com.jyh.proxy;\r\n\r\n/**\r\n * 接口\r\n * @author OverrideRe\r\n *\r\n */\r\npublic interface Human {\r\n\r\n	void sing(String name);\r\n	void dance(String name);\r\n}\r\n```\r\n实现类：\r\n```java\r\npackage com.jyh.proxy;\r\n\r\n/**\r\n * 实现接口的类\r\n * @author OverrideRe\r\n *\r\n */\r\npublic class Human1 implements Human {\r\n	\r\n	public Human1() {\r\n	}\r\n\r\n	public void sing(String name) {\r\n		System.out.println(name + \"在唱歌\");\r\n	}\r\n\r\n	public void dance(String name) {\r\n		System.out.println(name + \"在跳舞\");\r\n	}\r\n\r\n}\r\n```\r\n动态代理的实现：\r\n```java\r\npackage com.jyh.proxy;\r\n\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\npublic class Test1 {\r\n\r\n	/**\r\n	 * 基于接口的动态代理\r\n	 * @param args\r\n	 */\r\n	public static void main(String[] args) {\r\n		//被代理的类\r\n		final Human human = new Human1();\r\n		//代理类(传入的参数分别是：被代理类的类加载器，被代理类实现的接口们，传一个具体的策略方法)\r\n		Human h = (Human)Proxy.newProxyInstance(human.getClass().getClassLoader(), human.getClass().getInterfaces(), \r\n				new InvocationHandler() {\r\n					public Object invoke(Object proxy, Method method, Object[] args)\r\n							throws Throwable {\r\n						//每次调用方法都会通过这里，method就是调用的方法，args是方法的参数\r\n						if(\"sing\".equals(method.getName())){\r\n							System.out.println(\"你知道是谁在唱歌吗？\");\r\n							//这里用到了反射，human是该方法所在的实例\r\n							method.invoke(human, (String)args[0]);\r\n						}else{\r\n							method.invoke(human, (String)args[0]);\r\n						}\r\n						return \"这是什么\";\r\n					}\r\n			});\r\n		h.sing(\"不知道是谁\");\r\n		h.dance(\"同学\");\r\n	}\r\n}\r\n```\r\n观察上面发现，创建一个什么类的实例，都会通过```javaProxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, >InvocationHandler h)```\r\n而创建好实例之后无论调用被代理类的什么方法都会通过\r\n```javaInvocationHandler.invoke```\r\n方法，这个好像就是面向切面编程0.0(AOP)\r\n按照我的理解就是，好比砧板上一捆面，一刀切下去，形成一个切面，每条面都通过这个切面。\r\n## **数据库链接池的使用**\r\n### **原始的数据库链接池**\r\n```java\r\npackage com.jyh.jdbc.pool;\r\n\r\nimport java.io.PrintWriter;\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.sql.SQLFeatureNotSupportedException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\n\r\nimport javax.sql.DataSource;\r\n\r\nimport com.jyh.jdbc.JdbcUtil;\r\n\r\n//实现javax.sql.DataSource接口\r\npublic class MyDataSource implements DataSource {\r\n\r\n	//定义一个线程安全的集合\r\n	private static List<Connection> cl = Collections.synchronizedList(new ArrayList<Connection>());\r\n	\r\n	//初始化链接池\r\n	static{\r\n		for(int i = 0;i < 10; i ++){\r\n			cl.add(JdbcUtil.getConnection());\r\n		}\r\n	}\r\n\r\n	//从链接池中获取链接\r\n	public Connection getConnection(){\r\n		if(cl.size() > 0){\r\n			final Connection conn = cl.remove(0);//从连接池获取连接\r\n			//1.静态代理，需要用到装饰类\r\n			//Connection mconn = new MyConnection(conn, cl);//将连接和连接池交给自己编写的装饰类装饰一下\r\n			//2.动态代理\r\n			Connection c = (Connection)Proxy.newProxyInstance(conn.getClass().getClassLoader(), \r\n					new Class[]{Connection.class}, \r\n					new InvocationHandler() {\r\n						public Object invoke(Object proxy, Method method, Object[] args)\r\n								throws Throwable {\r\n							if(\"close\".equals(method.getName())){\r\n								cl.add(conn);\r\n								System.out.println(\"添加进连接池了\");\r\n							}else{\r\n								method.invoke(conn, args);\r\n							}\r\n							return null;\r\n						}\r\n					});\r\n			\r\n			return c;\r\n		}else{\r\n			throw new RuntimeException(\"服务器忙!\");\r\n		}\r\n	}\r\n\r\n	public static List<Connection> getCl() {\r\n		return cl;\r\n	}\r\n\r\n	public static void setCl(List<Connection> cl) {\r\n		MyDataSource.cl = cl;\r\n	}\r\n\r\n	public PrintWriter getLogWriter() throws SQLException {\r\n		return null;\r\n	}\r\n\r\n	public void setLogWriter(PrintWriter out) throws SQLException {\r\n\r\n	}\r\n\r\n	public void setLoginTimeout(int seconds) throws SQLException {\r\n\r\n	}\r\n\r\n	public int getLoginTimeout() throws SQLException {\r\n		return 0;\r\n	}\r\n\r\n	public Logger getParentLogger() throws SQLFeatureNotSupportedException {\r\n		return null;\r\n	}\r\n\r\n	public <T> T unwrap(Class<T> iface) throws SQLException {\r\n		return null;\r\n	}\r\n\r\n	public boolean isWrapperFor(Class<?> iface) throws SQLException {\r\n		return false;\r\n	}\r\n\r\n	public Connection getConnection(String username, String password)\r\n			throws SQLException {\r\n		return null;\r\n	}\r\n\r\n}\r\n```\r\n### **DBCP的使用**\r\n是apache的开源组件。\r\n1. 导入jar包commons-dbcp.jar commons-pool.jar\r\n2. 添加配置文件\r\n	```xml\r\n	<bean id=\"dataSource\"  \r\n          class=\"org.apache.commons.dbcp.BasicDataSource\"  \r\n          destroy-method=\"close\">  \r\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>  \r\n        <property name=\"url\" value=\"jdbc:mysql://192.168.0.109:3306/test?useUnicode=true&characterEncoding=UTF-8\"/>  \r\n        <property name=\"username\" value=\"root\"/>  \r\n        <property name=\"password\" value=\"root\"/>  \r\n        <!--maxActive: 最大连接数量-->    \r\n        <property name=\"maxActive\" value=\"150\"/>  \r\n        <!--minIdle: 最小空闲连接-->    \r\n        <property name=\"minIdle\" value=\"5\"/>  \r\n        <!--maxIdle: 最大空闲连接-->    \r\n        <property name=\"maxIdle\" value=\"20\"/>  \r\n        <!--initialSize: 初始化连接-->    \r\n        <property name=\"initialSize\" value=\"30\"/>  \r\n        <!-- 连接被泄露时是否打印 -->  \r\n        <property name=\"logAbandoned\" value=\"true\"/>  \r\n        <!--removeAbandoned: 是否自动回收超时连接-->    \r\n        <property name=\"removeAbandoned\"  value=\"true\"/>  \r\n        <!--removeAbandonedTimeout: 超时时间(以秒数为单位)-->    \r\n        <property name=\"removeAbandonedTimeout\" value=\"10\"/>  \r\n        <!--maxWait: 超时等待时间以毫秒为单位 1000等于60秒-->  \r\n        <property name=\"maxWait\" value=\"1000\"/>  \r\n        <!-- 在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位. -->  \r\n        <property name=\"timeBetweenEvictionRunsMillis\" value=\"10000\"/>  \r\n        <!--  在每次空闲连接回收器线程(如果有)运行时检查的连接数量 -->  \r\n        <property name=\"numTestsPerEvictionRun\" value=\"10\"/>  \r\n        <!-- 1000 * 60 * 30  连接在池中保持空闲而不被空闲连接回收器线程-->  \r\n        <property name=\"minEvictableIdleTimeMillis\" value=\"10000\"/>  \r\n    <property name=\"validationQuery\" value=\"SELECT NOW() FROM DUAL\"/>  \r\n    </bean>  \r\n	```\r\n3. 编写工具类：\r\n```java\r\npackage com.jyh.util;\r\n\r\nimport java.io.InputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\nimport org.apache.commons.dbcp.BasicDataSourceFactory;\r\n\r\npublic class DBCPUtil {\r\n	private static DataSource ds;\r\n	static{\r\n		InputStream in = DBCPUtil.class.getClassLoader().getResourceAsStream(\"dbcpconfig.xml\");\r\n		Properties ppt = new Properties();\r\n		try {\r\n			ppt.load(in);\r\n			ds = BasicDataSourceFactory.createDataSource(ppt);//根据配置文件创建数据连接池\r\n		} catch (Exception e) {\r\n			throw new ExceptionInInitializerError();\r\n		}\r\n		\r\n	}\r\n	\r\n	public static DataSource getDataSource(){\r\n		return ds;\r\n	}\r\n	\r\n	public static Connection getConnection(){\r\n		try {\r\n			return ds.getConnection();\r\n		} catch (SQLException e) {\r\n			throw new RuntimeException(\"获取数据库连接失败!\");\r\n		}\r\n	}\r\n}\r\n```\r\n### **C3P0的使用**\r\n1. 开源的数据源。c3p0-0.9.1.2.jar\r\n2. 编写配置文件\r\n	```xml\r\n	<!--acquireIncrement：链接用完了自动增量3个。 -->\r\n    <property name=\"acquireIncrement\">3</property>\r\n\r\n    <!--acquireRetryAttempts：链接失败后重新试30次。-->\r\n    <property name=\"acquireRetryAttempts\">30</property>\r\n \r\n    <!--acquireRetryDelay；两次连接中间隔1000毫秒。 -->\r\n    <property name=\"acquireRetryDelay\">1000</property>\r\n \r\n    <!--autoCommitOnClose：连接关闭时默认将所有未提交的操作回滚。 -->\r\n    <property name=\"autoCommitOnClose\">false</property>\r\n \r\n    <!--automaticTestTable：c3p0测试表，没什么用。-->\r\n    <property name=\"automaticTestTable\">Test</property>\r\n \r\n    <!--breakAfterAcquireFailure：出错时不把正在提交的数据抛弃。-->\r\n    <property name=\"breakAfterAcquireFailure\">false</property>\r\n \r\n    <!--checkoutTimeout：100毫秒后如果sql数据没有执行完将会报错，如果设置成0，那么将会无限的等待。 --> \r\n    <property name=\"checkoutTimeout\">100</property>\r\n \r\n    <!--connectionTesterClassName：通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester-->\r\n    <property name=\"connectionTesterClassName\"></property>\r\n \r\n    <!--factoryClassLocation：指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可。-->\r\n    <property name=\"factoryClassLocation\">null</property>\r\n \r\n    <!--forceIgnoreUnresolvedTransactions：作者强烈建议不使用的一个属性。--> \r\n    <property name=\"forceIgnoreUnresolvedTransactions\">false</property>\r\n \r\n    <!--idleConnectionTestPeriod：每60秒检查所有连接池中的空闲连接。--> \r\n    <property name=\"idleConnectionTestPeriod\">60</property>\r\n \r\n    <!--initialPoolSize：初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。 --> \r\n    <property name=\"initialPoolSize\">3</property>\r\n \r\n    <!--maxIdleTime：最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。-->\r\n    <property name=\"maxIdleTime\">60</property>\r\n \r\n    <!--maxPoolSize：连接池中保留的最大连接数。 -->\r\n    <property name=\"maxPoolSize\">15</property>\r\n \r\n    <!--maxStatements：最大链接数。-->\r\n    <property name=\"maxStatements\">100</property>\r\n \r\n    <!--maxStatementsPerConnection：定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0  -->\r\n    <property name=\"maxStatementsPerConnection\"></property>\r\n \r\n    <!--numHelperThreads：异步操作，提升性能通过多线程实现多个操作同时被执行。Default: 3--> \r\n    <property name=\"numHelperThreads\">3</property>\r\n \r\n    <!--overrideDefaultUser：当用户调用getConnection()时使root用户成为去获取连接的用户。主要用于连接池连接非c3p0的数据源时。Default: null--> \r\n    <property name=\"overrideDefaultUser\">root</property>\r\n \r\n    <!--overrideDefaultPassword：与overrideDefaultUser参数对应使用的一个参数。Default: null-->\r\n    <property name=\"overrideDefaultPassword\">password</property>\r\n \r\n    <!--password：密码。Default: null--> \r\n    <property name=\"password\"></property>\r\n \r\n    <!--preferredTestQuery：定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意： 测试的表必须在初始数据源的时候就存在。Default: null-->\r\n    <property name=\"preferredTestQuery\">select id from test where id=1</property>\r\n \r\n    <!--propertyCycle：用户修改系统配置参数执行前最多等待300秒。Default: 300 --> \r\n    <property name=\"propertyCycle\">300</property>\r\n \r\n    <!--testConnectionOnCheckout：因性能消耗大请只在需要的时候使用它。Default: false -->\r\n    <property name=\"testConnectionOnCheckout\">false</property>\r\n \r\n    <!--testConnectionOnCheckin：如果设为true那么在取得连接的同时将校验连接的有效性。Default: false -->\r\n    <property name=\"testConnectionOnCheckin\">true</property>\r\n \r\n    <!--user：用户名。Default: null-->\r\n    <property name=\"user\">root</property>\r\n \r\n    <!--usesTraditionalReflectiveProxies：动态反射代理。Default: false-->\r\n    <property name=\"usesTraditionalReflectiveProxies\">false</property>\r\n	```\r\n在配置文件中可以设置多套配置\r\n	```xml\r\n		<!-- 这个包裹下的是默认的一套配置 -->\r\n		<default-config></default-config>\r\n		<!-- 这个包裹下的是其它配置，可以在调用获取数据源的方法的时候传入name属性值指定那一套配置 -->\r\n	<named-config name=\"name\"></named-config>\r\n	```\r\n**3. 编写工具类**\r\n```java\r\npackage com.jyh.util;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n\r\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\r\n\r\npublic class C3P0Util {\r\n	private  static ComboPooledDataSource ds = new ComboPooledDataSource();//参数指代配置文件里的哪一套配置\r\n	\r\n	\r\n	public static DataSource getDataSource(){\r\n		return ds;\r\n	}\r\n	\r\n	public static Connection getConnection(){\r\n		try {\r\n			return ds.getConnection();\r\n		} catch (SQLException e) {\r\n			throw new RuntimeException(\"获取数据库连接失败!\");\r\n		}\r\n	}\r\n}\r\n```\r\n### **利用Web服务器管理数据源（JNDI）**\r\nJNDI：Java Naming and Directory Interface\r\n主流的web服务器都提供数据源的实现。基本只是配置一下即可。\r\n配置步骤：\r\na. 把数据库的驱动jar包，拷贝到Tomcat\\lib目录下\r\nb. 配置JNDI数据源\r\n在应用的META-INF目录下，建立一个context.xml的配置文件\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Context>\r\n	<!-- \r\n	name:放到JNDI容器中的名称\r\n	 -->\r\n	<Resource name=\"jdbc/test\" auth=\"Container\" type=\"javax.sql.DataSource\"\r\n               maxActive=\"30\" maxIdle=\"30\" maxWait=\"10000\"\r\n               username=\"root\" password=\"ying1995520***\" driverClassName=\"com.mysql.jdbc.Driver\"\r\n               url=\"jdbc:mysql://localhost:3306/database1\"/>\r\n</Context>\r\n```\r\nc. 获取数据源\r\n```java\r\npackage com.jyh.utils;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\n\r\nimport javax.naming.Context;\r\nimport javax.naming.InitialContext;\r\nimport javax.naming.NamingException;\r\nimport javax.sql.DataSource;\r\n\r\npublic class DataSourceUtil {\r\n	\r\n	private static DataSource ds;\r\n	\r\n	public static DataSource getDataSource(){\r\n		Context initContext;\r\n		try {\r\n			initContext = new InitialContext();\r\n			ds  = (DataSource)initContext.lookup(\"java:/comp/env/jdbc/test\");//路径\r\n		} catch (NamingException e) {\r\n			throw new RuntimeException(\"获取数据源失败!\");\r\n		}\r\n		return ds;\r\n	}\r\n	\r\n	public static Connection getConnection() throws SQLException{\r\n		return ds.getConnection();\r\n	}\r\n}\r\n```\r\n注意：该数据源是基于Web服务器的，所以要启动Web服务器才能使用\r\n## **JDBC框架简析**\r\n### **元信息的获取**\r\n```java\r\npackage com.jyh.test;\r\nimport java.sql.Connection;\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ParameterMetaData;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.jyh.util.DBCPUtil;\r\n\r\n/**\r\n * 数据库本身元数据的获取（数据库类型、版本、名称、表、列名等一系列信息）\r\n * @author OverrideRe\r\n *\r\n */\r\npublic class MetaDataTest {\r\n	//获取数据库名（MySQL？Oracle？）\r\n	@Test\r\n	public void test1() throws SQLException{\r\n		Connection conn = DBCPUtil.getConnection();\r\n		DatabaseMetaData dmd = conn.getMetaData();\r\n		System.out.println(dmd.getDatabaseProductName());\r\n		conn.close();\r\n	}\r\n	\r\n	//获取占位符个数\r\n	@Test\r\n	public void test2() throws Exception{\r\n		Connection conn = DBCPUtil.getConnection();\r\n		PreparedStatement st = conn.prepareStatement(\"??\");\r\n		ParameterMetaData pmd = st.getParameterMetaData();\r\n		System.out.println(pmd.getParameterCount());//打印占位符的个数\r\n		conn.close();\r\n	}\r\n	\r\n	//获取列的个数、列名和列的类型\r\n	@Test\r\n	public void test3() throws Exception{\r\n		Connection conn = DBCPUtil.getConnection();\r\n		PreparedStatement st = conn.prepareStatement(\"select * from customers\");\r\n		ResultSet rs = st.executeQuery();\r\n		ResultSetMetaData rsmd = rs.getMetaData();\r\n		int num = rsmd.getColumnCount();//获取多少列\r\n		for(int i = 1;i <= num; i ++){\r\n			String name = rsmd.getColumnName(i);//获取列名\r\n			int type = rsmd.getColumnType(i);//列的类型（数字表示）\r\n			//类型会打印出各种类型对应的数字，如int类型就是4，varchar（String）类型就是12\r\n			System.out.println(\"列名=\" + name + \",类型=\" + type);\r\n		}\r\n		conn.close();\r\n	}\r\n}\r\n```\r\n### **自己编写小型框架（约定优于编码）**\r\n问题：\r\n每次访问数据库都要建立链接太麻烦，所以丢给数据库链接池做了，那么每次访问数据库都要获取链接然后编写一大堆重复的代码能不能丢给别人做呢？我们可不可以封装一个类专门链接数据库更新数据获取数据呢？\r\n思考：\r\n每次处理数据库请求有什么相同的呢？\r\n啊，增加、删除和修改都是没有返回值的，而且除了sql语句和参数不同，其它都相同。而查找获取数据是有返回值的，除了sql语句和参数不同，还需要对返回的数据进行封装处理。\r\n根据这种思想，我们就可以利用元信息的获取来封装数据库的链接了。\r\n\r\n处理返回的结果集的接口：\r\n```java\r\npackage com.jyh.assist.test;\r\n\r\nimport java.sql.ResultSet;\r\n\r\n/**\r\n * 定义一个接口，应对不同的结果集有不同的处理方法，也就是本接口的不同实现\r\n * @author OverrideRe\r\n *\r\n */\r\npublic interface ResultSetHandle {\r\n	\r\n	public Object handle(ResultSet rs);\r\n}\r\n\r\n```\r\n处理返回的结果集中的一个实现类（实现对返回结果是对象集合的处理）：\r\n```java\r\npackage com.jyh.assist.test;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.text.DateFormat;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.List;\r\n\r\n/**\r\n * 本类是应对结果集为对象集合的处理方法\r\n * @author OverrideRe\r\n *\r\n */\r\n\r\npublic class ResultSetHnadleList implements ResultSetHandle {\r\n\r\n	Class<?> clazz;\r\n	\r\n	public ResultSetHnadleList(Class<?> clazz){\r\n		this.clazz = clazz;\r\n	}\r\n	\r\n	@Override\r\n	public Object handle(ResultSet rs) {\r\n		try {\r\n			List<Object> list = new ArrayList<>();\r\n			//遍历结果集中的数据\r\n			while(rs.next()){\r\n				//获取传过来的对象实例\r\n				Object bean = clazz.newInstance();\r\n				//获取结果集中的元数据(列的个数、列名和类型等)\r\n				ResultSetMetaData rsmd = rs.getMetaData();\r\n				//获取列的个数\r\n				int colNum = rsmd.getColumnCount();\r\n				//循环遍历列\r\n				for(int i = 0; i < colNum; i ++){\r\n					//获取列名\r\n					String colName = rsmd.getColumnName(i + 1);\r\n					//获取对应列名的数值\r\n					Object colValue = rs.getObject(i + 1);\r\n					//根据列名获取传过来的对象的属性\r\n					Field field = clazz.getDeclaredField(colName);\r\n					//进行私有属性爆破\r\n					field.setAccessible(true);\r\n					//如果该属性是Date类型则进行转换\r\n					if(Date.class.equals(field.getType())){\r\n						String cv = (String)colValue;\r\n						DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n						try {\r\n							colValue = df.parse(cv);\r\n						} catch (ParseException e) {\r\n							e.printStackTrace();\r\n						}\r\n					}\r\n					//对该属性进行赋值\r\n					field.set(bean, colValue);\r\n				}\r\n				//将该类添加到集合中去\r\n				list.add(bean);\r\n			}\r\n			return list;\r\n		} catch (InstantiationException e) {\r\n			e.printStackTrace();\r\n		} catch (IllegalAccessException e) {\r\n			e.printStackTrace();\r\n		} catch (NoSuchFieldException e) {\r\n			e.printStackTrace();\r\n		} catch (SecurityException e) {\r\n			e.printStackTrace();\r\n		} catch (IllegalArgumentException e) {\r\n			e.printStackTrace();\r\n		} catch (SQLException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n\r\n```\r\n具体的访问数据库的方法：\r\n```java\r\npackage com.jyh.assist.test;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.ParameterMetaData;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n\r\npublic class AssistDemo {\r\n\r\n	private DataSource ds;\r\n	\r\n	public AssistDemo(DataSource ds){\r\n		this.ds = ds;\r\n	}\r\n	\r\n	//处理没有返回结果集的方法\r\n	public void update(String sql,Object...params){\r\n		Connection conn = null;\r\n		PreparedStatement st = null;\r\n		ResultSet rs = null;\r\n		try{\r\n			conn = ds.getConnection();\r\n			st =conn.prepareStatement(sql);\r\n			//获取关于sql语句中的元数据(占位符个数)\r\n			ParameterMetaData pmd = st.getParameterMetaData();\r\n			int num = pmd.getParameterCount();//获取占位符个数\r\n			if(num > 0){\r\n				if(params == null){\r\n					throw new IllegalArgumentException(\"参数为空\");\r\n				}\r\n				if(params.length != num){\r\n					throw new IllegalArgumentException(\"参数个数不匹配\");\r\n				}\r\n				for(int i = 1; i <= num; i ++){\r\n					st.setObject(i, params[i-1]);\r\n				}\r\n			}\r\n			st.executeUpdate();\r\n		}catch(Exception e){\r\n			throw new RuntimeException(e);\r\n		}finally{\r\n			release(rs, st, conn);\r\n		}\r\n	}\r\n	\r\n	//处理有结果集的方法   rsh参数代表处理结果集的方法\r\n	public Object query(String sql,ResultSetHandle rsh,Object...params) {\r\n		Connection conn = null;\r\n		PreparedStatement st = null;\r\n		ResultSet rs = null;\r\n		try{\r\n			conn = ds.getConnection();\r\n			st =conn.prepareStatement(sql);\r\n			ParameterMetaData pmd = st.getParameterMetaData();\r\n			int num = pmd.getParameterCount();\r\n			if(num > 0){\r\n				if(params == null){\r\n					throw new IllegalArgumentException(\"参数为空\");\r\n				}\r\n				if(params.length != num){\r\n					throw new IllegalArgumentException(\"参数个数不匹配\");\r\n				}\r\n				for(int i = 1; i <= num; i ++){\r\n					st.setObject(i, params[i-1]);\r\n				}\r\n			}\r\n			//获取结果集\r\n			rs = st.executeQuery();\r\n			return rsh.handle(rs);\r\n		}catch(Exception e){\r\n			throw new RuntimeException(e);\r\n		}finally{\r\n			release(rs, st, conn);\r\n		}\r\n	}\r\n	\r\n	public void release(ResultSet rs,Statement st,Connection conn){\r\n		if(st != null){\r\n			try {\r\n				st.close();\r\n			} catch (SQLException e) {\r\n				e.printStackTrace();\r\n			}\r\n			st = null;\r\n		}\r\n		if(rs != null){\r\n			try {\r\n				rs.close();\r\n			} catch (SQLException e) {\r\n				e.printStackTrace();\r\n			}\r\n			rs = null;\r\n		}\r\n		if(conn != null){\r\n			try {\r\n				conn.close();\r\n			} catch (SQLException e) {\r\n				e.printStackTrace();\r\n			}\r\n			conn = null;\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n调用：\r\n```java\r\npackage com.jyh.assist.test;\r\n\r\nimport java.util.List;\r\n\r\nimport jyh.com.domain.Account;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.jyh.utils.DBCPUtil;\r\n\r\n\r\npublic class AssistTest {\r\n\r\n	private AssistDemo a = new AssistDemo(DBCPUtil.getDataSource());\r\n	@Test\r\n	public void addAccount(){\r\n		a.update(\"insert into account(name,salary) values(?,?)\", \"ddd\",\"1000\");\r\n	}\r\n	\r\n	@Test\r\n	public void getAllAccount(){\r\n		@SuppressWarnings(\"unchecked\")\r\n		List<Account> list = (List<Account>) a.query(\"select * from account\", new ResultSetHnadleList(Account.class));\r\n		System.out.println(list.size());\r\n	}\r\n	\r\n	@Test\r\n	public void getCount(){\r\n		Integer num = (Integer) a.query(\"select count(*) from account\", null);\r\n		System.out.println(num);\r\n	}\r\n}\r\n\r\n```\r\n\r\n## **策略模式？**\r\n看以前写的和今天写的代码，发现已经好几次出现自己编写一个类继承某个接口实现“一个”方法的情况了。就拿上面的例子，我编写了一个ResultSetHandle接口，该接口只有一个public Object handle(ResultSet rs);方法，然后我在编写一个ResultSetHnadleList类去实现这个接口，然后编写方法实现。然后怎么用这个呢？是将该类的实例作为一个参数传递过去。貌似这种方式就是策略模式0.0，在我的理解就是，某些时候需要传递的并不是数据，而是一个具体的方法，但是方法并不能传递，只能通过类的实例调用，于是就传一个类的实例好了，这个类里面实现了需要的方法，但是为什么要接口呢？因为不同的情况有不同的实现啊！！！比如说上面我实现了如果结果集是集合数据，万一返回的是一个int类型数字呢？那肯定要不同的实现方法了。\r\n', null, '2017-03-01 03:00:00', '402881f25a82814c015a83317e6e0009', '116', 'java,jdbc,dbutils', '1', '3', null, '1');
INSERT INTO `article` VALUES ('402881f25a8a68e1015a8a6968e90000', 'SpringMVC', '#**Spring web mvc 架构**\r\n##**架构图**\r\n![这里写图片描述](http://img.blog.csdn.net/20170214102240295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n##**流程**', '# **Spring web mvc 架构**\r\n## **流程**\r\n1. 用户发送请求至前端控制器DispatcherServlet\r\n2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。\r\n3. 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\r\n4. DispatcherServlet调用HandlerAdapter处理器适配器\r\n5. HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\r\n6. Controller执行完成返回ModelAndView\r\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet\r\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器\r\n9. ViewReslover解析后返回具体View\r\n10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\r\n11. DispatcherServlet响应用户\r\n## **组件说明**\r\n以下组件通常使用框架提供实现：\r\n**DispatcherServlet**：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。\r\n**HandlerMapping**：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\r\n**HandlAdapter**：通过扩展处理器适配器，支持更多类型的处理器。\r\n**ViewResolver**：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。\r\n\r\n下边两个组件通常情况下需要开发：\r\n**Handler**：处理器，即后端控制器用controller表示。\r\n**View**：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\r\n# **第一个SpringMVC工程**\r\n## **配置前端控制器**\r\n在web.xml配置文件中\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n	xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n	id=\"WebApp_ID\" version=\"3.1\">\r\n	<display-name>MySpringMVC</display-name>\r\n	\r\n	<!-- 解决post请求中文乱码 -->\r\n	<filter>\r\n		<filter-name>CharacterEncodingFilter</filter-name>\r\n		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n		<init-param>\r\n			<param-name>encoding</param-name>\r\n			<param-value>utf-8</param-value>\r\n		</init-param>\r\n	</filter>\r\n	<filter-mapping>\r\n		<filter-name>CharacterEncodingFilter</filter-name>\r\n		<url-pattern>/*</url-pattern>\r\n	</filter-mapping>\r\n\r\n\r\n	<!-- 前端控制器 -->\r\n	<servlet>\r\n		<servlet-name>springmvc</servlet-name>\r\n		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n		<!--\r\n			指定springmvc配置的加载位置，如果不指定则默认加\r\n			载WEB-INF/[DispatcherServlet 的Servlet 名字]-servlet.xml。\r\n		 -->\r\n		<init-param>\r\n			<param-name>contextConfigLocation</param-name>\r\n			<param-value>classpath:springmvc-servlet.xml</param-value>\r\n		</init-param>\r\n		<load-on-startup>1</load-on-startup>\r\n	</servlet>\r\n	<servlet-mapping>\r\n		<servlet-name>springmvc</servlet-name>\r\n		<url-pattern>*.action</url-pattern>\r\n	</servlet-mapping>\r\n\r\n\r\n	<welcome-file-list>\r\n		<welcome-file>index.html</welcome-file>\r\n		<welcome-file>index.htm</welcome-file>\r\n		<welcome-file>index.jsp</welcome-file>\r\n		<welcome-file>default.html</welcome-file>\r\n		<welcome-file>default.htm</welcome-file>\r\n		<welcome-file>default.jsp</welcome-file>\r\n	</welcome-file-list>\r\n</web-app>\r\n```\r\n## **SpringMVC配置文件**\r\n### **SpringMVC配置文件的加载位置**\r\nSpringmvc默认加载WEB-INF/[前端控制器的名字]-servlet.xml，也可以在前端控制器定义处指定加载的配置文件，如下：\r\n```xml\r\n<!--\r\n    指定springmvc配置的加载位置，如果不指定则默认加\r\n    载WEB-INF/[DispatcherServlet 的Servlet 名字]-servlet.xml。\r\n -->\r\n<init-param>\r\n    <param-name>contextConfigLocation</param-name>\r\n    <param-value>classpath:springmvc-servlet.xml</param-value>\r\n</init-param>\r\n```\r\n如上代码，通过contextConfigLocation加载classpath下的springmvc-servlet.xml配置文件，配置文件名称可以不限定[前端控制器的名字]-servlet.xml。\r\n### **配置处理器映射器**\r\n```xml\r\n<!-- 处理器映射器 -->\r\n<!-- BeanNameUrlHandlerMapping：表示将定义的处理器（controller）Bean的名字作为请求的url， \r\n且必须以.action结尾，比如下面的/hello.action -->\r\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" />\r\n\r\n<!-- 简单url映射器,key为路径名,值为处理器(controller)对应bean的id -->\r\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\r\n	<property name=\"mappings\">\r\n		<props>\r\n			<prop key=\"/hello0.action\">hello_controller</prop>\r\n			<prop key=\"/hello1.action\">hello_controller</prop>\r\n			<prop key=\"/hello2.action\">hello_controller2</prop>\r\n		</props>\r\n	</property>\r\n</bean>\r\n```\r\n### **配置处理器适配器**\r\n```xml\r\n<!-- 处理器适配器,多个处理器适配器可以共存,适配器的意思就是根据不同的处理器寻找对应的适配器进行请求转换然后对接处理器 -->\r\n	<!-- SimpleControllerHandlerAdapter：即简单控制器处理适配器， 所有实现了org.springframework.web.servlet.mvc.Controller \r\n		接口的Bean作为 Springmvc的后端控制器。 -->\r\n	<bean\r\n		class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" />\r\n\r\n	<!-- HTTP请求处理器适配器 HTTP请求处理器适配器将http请求封装成HttpServletResquest 和HttpServletResponse对象，和servlet接口类似。 \r\n		适配器配置如下： -->\r\n	<bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\" />\r\n```\r\n### **配置视图解析器**\r\n```xml\r\n<!-- ViewResolver视图解析器 -->\r\n<!-- InternalResourceViewResolver：支持JSP视图解析 viewClass：JstlView表示JSP模板页面需要使用JSTL标签库， \r\n	所以classpath中必须包含jstl的相关jar 包； prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为： 前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定， \r\n	比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” -->\r\n<bean\r\n	class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n	<property name=\"viewClass\"\r\n		value=\"org.springframework.web.servlet.view.JstlView\" />\r\n	<property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\r\n	<property name=\"suffix\" value=\".jsp\" />\r\n</bean>\r\n```\r\n### **后端控制器配置**\r\n```xml\r\n<!--处理器 -->\r\n	<bean name=\"/hello.action\" class=\"com.jyh.controller.HelloWorldController\" />\r\n	<bean id=\"hello_controller\" class=\"com.jyh.controller.HelloWorldController\" />\r\n	<bean id=\"hello_controller2\" class=\"com.jyh.controller.HelloWorldController2\" />\r\n```\r\n## **后端控制器开发**\r\nhello1\r\n```java\r\npackage com.jyh.controller;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport org.springframework.web.servlet.ModelAndView;\r\nimport org.springframework.web.servlet.mvc.Controller;\r\n\r\npublic class HelloWorldController implements Controller {\r\n	@Override\r\n	public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {\r\n		ModelAndView mv = new ModelAndView();\r\n		//添加模型数据\r\n		mv.addObject(\"message\", \"Hello World1111!\");\r\n		//设置逻辑视图名,最终视图地址=前缀+逻辑视图名+后缀\r\n		mv.setViewName(\"hello\");\r\n		return mv;\r\n	}\r\n}\r\n\r\n```\r\nhello2\r\n```java\r\npackage com.jyh.controller;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.springframework.web.HttpRequestHandler;\r\n\r\npublic class HelloWorldController2 implements HttpRequestHandler {\r\n\r\n	@Override\r\n	public void handleRequest(HttpServletRequest request,\r\n			HttpServletResponse response) throws ServletException, IOException {\r\n		request.setAttribute(\"message\", \"HelloWorld22222!\");\r\n		request.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(request, response);\r\n		//也可以自定义响应内容\r\n		//response.setCharacterEncoding(\"utf-8\");\r\n		//response.getWriter().write(\"HelloWorld!\");\r\n	}\r\n\r\n}\r\n```\r\n## **视图开发**\r\n```xml\r\n<body>\r\n   ${message}\r\n</body>\r\n```\r\n# **注解开发**\r\n## **xml配置**\r\n```xml\r\n<!-- ********************注解配置******************** -->\r\n<!-- 注解映射器和注解适配器可以使用<mvc:annotation-driven/>代替,默认注册了注解映射器和注解适配器等bean。 -->\r\n<mvc:annotation-driven />\r\n\r\n<context:component-scan base-package=\"com.jyh.controller\"></context:component-scan>\r\n\r\n<!-- 注解处理映射器\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" />\r\n -->\r\n \r\n<!--注解适配器\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" />\r\n -->\r\n \r\n <!-- 处理器\r\n<bean class=\"com.jyh.controller.AnnotationHelloWorld\" />\r\n -->\r\n \r\n<!-- json数据传输\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n	<property name=\"messageConverters\">\r\n		<list>\r\n			<bean\r\n				class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"></bean>\r\n		</list>\r\n	</property>\r\n</bean> \r\n-->\r\n```\r\n## **编写控制器类**\r\n```java\r\n@Controller\r\n// 表示处理器 value为类访问路径，即根路径 method为请求方式\r\n@RequestMapping(value = \"/student\", method = { RequestMethod.GET,\r\n		RequestMethod.POST })\r\npublic class AnnotationHelloWorld extends Binder {\r\n\r\n	//value为方法访问路径，即子路径，要访问本方法需要这样写/student/getStudent.action\r\n	@RequestMapping(value = \"/getStudent\")\r\n	public String getStudent(Model model) throws Exception {\r\n		Student student = new Student();\r\n		student.setId(1);\r\n		student.setName(\"学生\");\r\n		student.setGender(\"男\");\r\n		student.setBirthday(new Date());\r\n		model.addAttribute(\"student\", student);\r\n		return \"getStudent\";\r\n	}\r\n}\r\n```\r\n## **url模板映射**\r\n```java\r\n@RequestMapping(\"/student/{groupid}/{userid}\")\r\n// 占位符{xxx}\r\npublic String useredit(@PathVariable String groupid,\r\n		@PathVariable String userid, Model model) throws Exception {\r\n	// 方法中使用@PathVariable获取路径中对应占位符的值，使用model传回页面\r\n	model.addAttribute(\"message\", groupid + userid);\r\n	return \"success\";\r\n}\r\n```\r\n# **请求数据绑定**\r\n## **默认参数类型**\r\n```java\r\n@RequestMapping(\"/userlist\")\r\npublic String userlist(HttpServletRequest request,\r\n		HttpServletResponse response, HttpSession session, Model model) {\r\n	System.out.println(request.getClass().getName());\r\n	System.out.println(response.getClass().getName());\r\n	System.out.println(session.getClass().getName());\r\n	return \"\";\r\n}\r\n```\r\n默认参数类型：\r\n**HttpServletRequest**：通过request对象获取请求信息\r\n**HttpServletResponse**：通过response处理响应信息\r\n**HttpSession**：通过session对象得到session中存放的对象\r\n**Model**：通过model向页面传递数据，如下：\r\nmodel.addAttribute(\"user\", new User(\"李四\"));\r\n页面通过${user.XXXX}获取user对象的属性值。\r\n## **基本类型**\r\n请求：http://localhost:8080/MySpringMVC/student/parameter.action?\r\nparam=bbb\r\n\r\n处理：\r\n```java\r\n//单个参数\r\n@RequestMapping(\"/parameter\")\r\npublic ModelAndView parameter(@RequestParam(defaultValue=\"aaa\",value=\"param\",required=true)String parameter) {\r\n	ModelAndView mv = new ModelAndView();\r\n	mv.setViewName(\"success\");\r\n	mv.addObject(\"message\", parameter);\r\n	//return \"redirect:/parameter.action\"         重定向\r\n	//return \"forward:/parameter.action\"          转发\r\n	return mv;\r\n}\r\n```\r\n## **POJO对象**\r\n### **直接POJO对象属性名命名的**\r\n页面表单：\r\n```xml\r\n<form action=\"${pageContext.request.contextPath}/student/updateStudent.action\" method=\"post\">\r\n   	<input type=\"hidden\" name=\"id\" value=\"${student.id}\"/><br/>\r\n   	<input type=\"text\" name=\"name\" value=\"${student.name}\"/><br/>\r\n   	<input type=\"text\" name=\"gender\" value=\"${student.gender}\"/><br/>\r\n   	<input type=\"text\" name=\"birthday\" value=\"${student.birthday}\"/><br/>\r\n	<input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n```\r\ncontroller:\r\n```java\r\n@RequestMapping(value = \"/updateStudent\")\r\npublic String updateStudent(Model model, Student student) throws Exception {\r\n	System.out.println(student);\r\n	model.addAttribute(\"message\", \"编辑成功!\");\r\n	return \"success\";\r\n}\r\n```\r\n### **POJO对象点属性名命名的**\r\n页面：\r\n```xml\r\n <form action=\"${pageContext.request.contextPath}/student/updateStudent2.action\" method=\"post\">\r\n   	<input type=\"hidden\" name=\"student.id\" value=\"${student.id}\"/><br/>\r\n   	<input type=\"text\" name=\"student.name\" value=\"${student.name}\"/><br/>\r\n   	<input type=\"text\" name=\"student.gender\" value=\"${student.gender}\"/><br/>\r\n   	<input type=\"text\" name=\"student.birthday\" value=\"${student.birthday}\"/><br/>\r\n   	<input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n```\r\ncontroller：\r\n```java\r\n@RequestMapping(value = \"/updateStudent2\")\r\npublic String updateStudent2(Model model, Student2 student2) throws Exception {\r\n	System.out.println(\"------\");\r\n	System.out.println(student2.getStudent());\r\n	model.addAttribute(\"student\", student2.getStudent());\r\n	return \"getStudent\";\r\n}\r\n```\r\nstudent2：\r\n```java\r\npackage com.jyh.domain;\r\n\r\nimport java.io.Serializable;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class Student2 implements Serializable {\r\n\r\n	private Student student;\r\n\r\n	public Student getStudent() {\r\n		return student;\r\n	}\r\n\r\n	public void setStudent(Student student) {\r\n		this.student = student;\r\n	}\r\n	\r\n}\r\n```\r\n**注意：**\r\n有时候需要传递日期等无法识别的类型，这时候需要进行类型注册，在controller里面添加initBinder方法，上面加上一个注解@InitBinder，方法里面注册编辑器，也可以将该方法写在一个类里面，然后其他controller继承该类\r\n```java\r\n@InitBinder\r\npublic void initBinder(HttpServletRequest request,\r\n		ServletRequestDataBinder binder) throws Exception {\r\n	binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(\"yyyy-MM-dd\"),true));\r\n	//binder.registerCustomEditor(requiredType, propertyEditor);\r\n}\r\n```\r\n## **集合数据**\r\n### **list集合**\r\n页面：\r\n```xml\r\n<form action=\"${pageContext.request.contextPath}/student/updateStudentList.action\" method=\"post\">\r\n    <table>\r\n    	<c:forEach items=\"${studentList}\" var=\"student\" varStatus=\"num\">\r\n    		<tr>\r\n	  			<td><input type=\"text\" name=\"studentList[${num.index}].id\" value=\"${student.id}\"/></td>\r\n	  			<td><input type=\"text\" name=\"studentList[${num.index}].name\" value=\"${student.name}\"/></td>\r\n	  			<td><input type=\"text\" name=\"studentList[${num.index}].gender\" value=\"${student.gender}\"/></td>\r\n	  			<td><input type=\"text\" name=\"studentList[${num.index}].birthday\" value=\"${student.birthday}\"/></td>\r\n	  		</tr>\r\n    	</c:forEach>\r\n  	</table>\r\n  	<input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n```\r\ncontroller：\r\n```java\r\n@RequestMapping(value = \"/updateStudentList\")\r\npublic String updateStudentList(Model model, StudentList studentList) throws Exception {\r\n	System.out.println(\"------\");\r\n	System.out.println(studentList.getStudentList());\r\n	model.addAttribute(\"studentList\", studentList.getStudentList());\r\n	return \"studentList\";\r\n}\r\n```\r\nStudentList：\r\n```java\r\npackage com.jyh.domain;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.List;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class StudentList implements Serializable {\r\n\r\n	private List<Student> studentList;\r\n\r\n	public List<Student> getStudentList() {\r\n		return studentList;\r\n	}\r\n\r\n	public void setStudentList(List<Student> studentList) {\r\n		this.studentList = studentList;\r\n	}\r\n	\r\n}\r\n\r\n```\r\n### **map集合**\r\n页面：\r\n```xml\r\n<form\r\n		action=\"${pageContext.request.contextPath}/student/updateStudentMap.action\"\r\n		method=\"post\">\r\n	<table>\r\n		<c:forEach items=\"${studentMap}\" var=\"student\">\r\n			<tr>\r\n				<td><input type=\"text\" name=\"studentMap[\'${student.key}\'].id\"\r\n					value=\"${student.value.id}\" /></td>\r\n				<td><input type=\"text\" name=\"studentMap[\'${student.key}\'].name\"\r\n					value=\"${student.value.name}\" /></td>\r\n				<td><input type=\"text\" name=\"studentMap[\'${student.key}\'].gender\"\r\n					value=\"${student.value.gender}\" /></td>\r\n				<td><input type=\"text\" name=\"studentMap[\'${student.key}\'].birthday\"\r\n					value=\"${student.value.birthday}\" /></td>\r\n			</tr>\r\n		</c:forEach>\r\n	</table>\r\n	<input type=\"submit\" value=\"提交\" />\r\n</form>\r\n```\r\n## **json数据**\r\njs：\r\n```javascript\r\n/**\r\n * json数据传输测试\r\n */\r\n\r\n$(function(){\r\n	$(\"#form\").click(function(){\r\n		myEvent.request_form();\r\n	});\r\n	$(\"#json\").click(function(){\r\n		myEvent.request_json();\r\n	});\r\n});\r\n\r\nvar myEvent = {\r\n	request_json:function(){\r\n		//json格式数据提交\r\n		var user = JSON.stringify({id:1,name: \"张三\", gender: \"男\",birthday:\"1995-04-10\"});\r\n		$.ajax(\r\n			{\r\n				type:\'post\',\r\n				url:\'student/requestjson.action\',\r\n				contentType:\'application/json;charset=utf-8\',		//请求内容为json\r\n				data:user,\r\n				success:function(data){\r\n					alert(data.name);\r\n				},\r\n				error:function(){\r\n					alert(\"没有返回\");\r\n				}\r\n			}	\r\n		);\r\n	},\r\n	\r\n	request_form:function(){\r\n		//表单提交\r\n		var user = \"id=1&name=张三&gender=男&birthday=1995-04-10\"\r\n		$.ajax(\r\n			{\r\n				type:\'post\',\r\n				url:\'student/formRequest.action\',\r\n				data:user,\r\n				success:function(data){\r\n					alert(data.name);\r\n				},\r\n				error:function(){\r\n					alert(\"没有返回\");\r\n				}\r\n			}	\r\n		);\r\n	}\r\n\r\n};\r\n```\r\ncontroller：\r\n```java\r\n//接收json数据,返回json数据\r\n@RequestMapping(\"/requestjson\")\r\n   //@RequestBody接收json串自动转为student对象，@ResponseBody将student对象转为json数据响应给客户端\r\npublic @ResponseBody Student requestjson(@RequestBody Student student)throws Exception{\r\n	System.out.println(student);\r\n	return student;\r\n}\r\n\r\n//接收表单数据,返回json数据\r\n@RequestMapping(\"/formRequest\")\r\npublic @ResponseBody Student formRequest(Student student)throws Exception{\r\n	System.out.println(student);\r\n	return student;\r\n}\r\n```\r\n# **拦截器**\r\nxml配置：\r\n```xml\r\n<!-- 对某种映射器配置拦截器 -->\r\n <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\r\n	<property name=\"interceptors\">\r\n		<list>\r\n			<ref bean=\"handlerInterceptor1\" />\r\n		</list>\r\n	</property>\r\n</bean>\r\n<bean id=\"handlerInterceptor1\" class=\"com.jyh.handlerinterceptor.MyHandlerInterceptor1\" />\r\n \r\n <!--全局拦截器 -->\r\n<mvc:interceptors>\r\n	<!--多个拦截器,顺序执行 -->\r\n	<mvc:interceptor>\r\n		<mvc:mapping path=\"/**\"/>\r\n		<bean class=\"com.jyh.handlerinterceptor.MyHandlerInterceptor1\"></bean>\r\n	</mvc:interceptor>\r\n	<mvc:interceptor>\r\n		<mvc:mapping path=\"/**\"/>\r\n		<bean class=\"com.jyh.handlerinterceptor.MyHandlerInterceptor1\"></bean>\r\n	</mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\njava代码：\r\n```java\r\npackage com.jyh.handlerinterceptor;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.springframework.web.servlet.HandlerInterceptor;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\npublic class MyHandlerInterceptor1 implements HandlerInterceptor {\r\n\r\n	/**\r\n	 * controller执行前调用此方法\r\n	 * 返回true表示继续执行，返回false中止执行\r\n	 * 这里可以加入登录校验、权限拦截等\r\n	 */\r\n	\r\n	@Override\r\n	public boolean preHandle(HttpServletRequest request,\r\n			HttpServletResponse response, Object handler) throws Exception {\r\n		return true;\r\n	}\r\n\r\n	/**\r\n	 * controller执行后但未返回视图前调用此方法\r\n	 * 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示\r\n	 */\r\n	\r\n	@Override\r\n	public void postHandle(HttpServletRequest request,\r\n			HttpServletResponse response, Object handler,\r\n			ModelAndView modelAndView) throws Exception {\r\n\r\n	}\r\n	\r\n	/**\r\n	 * controller执行后且视图返回后调用此方法\r\n	 * 这里可得到执行controller时的异常信息\r\n	 * 这里可记录操作日志，资源清理等\r\n	 */\r\n\r\n	@Override\r\n	public void afterCompletion(HttpServletRequest request,\r\n			HttpServletResponse response, Object handler, Exception ex)\r\n			throws Exception {\r\n\r\n	}\r\n\r\n}\r\n\r\n```\r\n\r\n# **与struts2不同**\r\n1. springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。\r\n2. springmvc是基于方法开发，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\r\n3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。\r\n\r\n\r\n', null, '2017-03-01 15:07:28', '402881f25a82814c015a83317e6e0009', '144', 'spring,springMVC,java', '0', '4', null, '1');
INSERT INTO `article` VALUES ('402881f25ac80e96015ac81092fb0001', 'DBUtils和ThreadLocal', 'DBUtils导包commons-dbutils-xxx.jar包和commons-pool-xxx.jar包，xxx是版本号。使用packagecom.jyh.dbutil;importjava.sql.SQLException;importjava.util.Date;importjava.util.List;importjava.util.Map;importorg.apache.commo', '### **DBUtils**\n1. 导包\n	commons-dbutils-xxx.jar包和commons-pool-xxx.jar包，xxx是版本号。\n2. 使用\n	```java\n	package com.jyh.dbutil;\n\n	import java.sql.SQLException;\n	import java.util.Date;\n	import java.util.List;\n	import java.util.Map;\n	\n	import org.apache.commons.dbutils.QueryRunner;\n	import org.apache.commons.dbutils.handlers.ArrayHandler;\n	import org.apache.commons.dbutils.handlers.ArrayListHandler;\n	import org.apache.commons.dbutils.handlers.BeanHandler;\n	import org.apache.commons.dbutils.handlers.BeanListHandler;\n	import org.apache.commons.dbutils.handlers.ColumnListHandler;\n	import org.apache.commons.dbutils.handlers.KeyedHandler;\n	import org.apache.commons.dbutils.handlers.MapHandler;\n	import org.apache.commons.dbutils.handlers.MapListHandler;\n	import org.apache.commons.dbutils.handlers.ScalarHandler;\n	import org.junit.Test;\n	\n	import com.jyh.domain.User;\n	import com.jyh.jdbc.DBCPUtil;\n	\n	/**\n	 * dbutils框架的使用\n	 * @author OverrideRe\n	 *\n	 */\n	public class DBUtilDemo {\n	\n		/**\n		 * 传入数据源代表不需要事务,不传代表需要事务\n		 *传入数据源说明是从数据源随机获取链接，不一定是同一个链接，所以没法进行事务操作\n		 *如果需要进行事务操作需要同一个链接\n		 */\n		private QueryRunner qr = new QueryRunner(DBCPUtil.getDataSource());\n		\n		//没有返回值的增删改等\n		@Test\n		public void test1() throws SQLException{\n			qr.update(\"insert into user(name,password,email,birthday) values(?,?,?,?)\", \"大狗\",\"123\",\"dagou@qq.com\",\"1994-01-01\");\n		}\n		\n		//批处理\n		@Test\n		public void test2() throws SQLException{\n			Object[][] params = new Object [10][];\n			for(int i = 0;i < 10;i ++){\n				params[i] = new Object[]{\"a\"+i,\"123\",\"a\"+i+\"@qq.com\",new Date()};\n			}\n			qr.batch(\"insert into user(name,password,email,birthday) values(?,?,?,?)\", params);\n		}\n		\n		//ArrayHandler:有一条返回结果的查询语句,查询结果封装到一个Object[]中去\n		@Test\n		public void test3() throws SQLException{\n			Object[] objs = qr.query(\"select * from user\", new ArrayHandler());\n			for(Object obj : objs)\n				System.out.println(obj);\n		}\n		\n		//ArrayListHandler:有多条返回结果的查询语句,查询结果先将每条封装到一个Object[]中去,再封装到list中去\n		@Test\n		public void test4() throws SQLException{\n			List<Object[]> list = qr.query(\"select * from user\", new ArrayListHandler());\n			for (Object[] objects : list) {\n				for (Object object : objects) {\n					System.out.print(object + \"---\");\n				}\n				System.out.println();\n			}\n		}\n		\n		//ColumnListHandler:封装某列的值,将某一列的值封装进list中去\n		@Test\n		public void test5() throws SQLException{\n			//ColumnListHandler有两种构造方法，一种是传列的序号，一种是传列名\n			List<Object> list = qr.query(\"select * from user\", new ColumnListHandler(\"name\"));\n			for (Object object : list) {\n				System.out.print(object + \"---\");\n			}\n			System.out.println();\n		}\n		\n		/**KeyedHandler:以键值对形式封装数据,每条记录封装进键值对集合，value为各属性值，key为各属性值对应的属性名\n		 *然后再将每条记录封装进键值集合,key值自己定(一般为id),value值就是每条记录，也就是刚刚封装的键值对集合\n		 *意思就是双重map\n		 */\n		@Test\n		public void test6() throws SQLException{\n			Map<Object, Map<String, Object>> keyMap = qr.query(\"select * from user\", new KeyedHandler(\"id\"));\n			for (Map.Entry<Object, Map<String, Object>> enMap : keyMap.entrySet()) {\n				System.out.print(\"key:\" + enMap.getKey());\n				for (Map.Entry<String, Object> en: enMap.getValue().entrySet()) {\n					System.out.print(\"---\" + en.getKey() + \":\" + en.getValue());\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n		\n		//MapHandler:取一条数据,将列名和所对应的值以键值对形式封装\n		@Test\n		public void test7() throws SQLException{\n			Map<String, Object> keyMap = qr.query(\"select * from user\", new MapHandler());\n			for (Map.Entry<String, Object> en : keyMap.entrySet()) {\n				System.out.println(en.getKey() + \":\" + en.getValue());\n			}\n			System.out.println();\n		}\n		\n		//MapListHandler:取多条数据,将列名和所对应的值以键值对形式封装进map集合，然后再将map集合装进list中去\n		//与KeyedHandler不同的是,每一条数据是装在List中而不是Map键值对集合中\n		@Test\n		public void test8() throws SQLException{\n			List<Map<String, Object>> keyList = qr.query(\"select * from user\", new MapListHandler());\n			for (Map<String, Object> enMap : keyList) {\n				for (Map.Entry<String, Object> en: enMap.entrySet()) {\n					System.out.print(\"---\" + en.getKey() + \":\" + en.getValue());\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n		\n		//ScalarHandler:返回某行某列的一个数据,如查询总数coutn(*)\n		@Test\n		public void test9() throws SQLException{\n			Object l= qr.query(\"select * from user\", new ScalarHandler());\n			System.out.println(l);\n		}\n		\n		//BeanHandler:将一条数据封装进某个bean类中去\n		@Test\n		public void test10() throws SQLException{\n			User l= qr.query(\"select * from user\", new BeanHandler<User>(User.class));\n			System.out.println(l.getName());\n		}\n		\n		//BeanListHandler:获取多条数据，将每条数据封装进bean中然后再添加进集合中去\n		@Test\n		public void test11() throws SQLException{\n			List<User> l= qr.query(\"select * from user\", new BeanListHandler<User>(User.class));\n			System.out.println(l.get(0).getName());\n		}\n	}\n\n	```\n### **ThreadLocal**\nThreadLocal为线程局部变量，看着名字就知道是保存在线程上的变量\n1. 声明实例：`ThreadLocal<T> tl = new ThreadLocal<T>();`\nT为要保存的数据类型。\n2. 常用方法：set(T t),get(),remove()。\n3. 作用：将数据保存在当前线程中，为线程私有，利用线程之间的互相隔离，保证\n变量只能在当前线程中被改变。普通的变量就是保存在外面，任何线程都可以访问，所以每个线程访问的数据都可能是经过别的线程改变之后的数据。\n4. 实现原理：查看源码。\n	为了文章的长度，把源码加上：\n	set(T value)方法：\n```java\n public void set(T value) {\n      Thread t = Thread.currentThread();\n      ThreadLocalMap map = getMap(t);\n      if (map != null)\n          map.set(this, value);\n      else\n          createMap(t, value);\n  }	\n```\nset方法中调用的getMap(Thread t)方法\n```java\nThreadLocalMap getMap(Thread t) {\n       return t.threadLocals;\n   }\n```\nset方法中调用的creatMap(Thread t, T firstValue)方法：\n```java\n void createMap(Thread t, T firstValue) {\n       t.threadLocals = new ThreadLocalMap(this, firstValue);\n   }\n```\nThread类中的threadLocals 参数：\n```java\n/* ThreadLocal values pertaining to this thread. This map is maintained\n    * by the ThreadLocal class. */\n   ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n查看以上代码可知，set方法是将要保存的数据作为value，当前ThreadLocal实例作为key值保存在当前线程中的一个map中，这个map类是ThreadLocal.ThreadLocalMap，是ThreadLocal的内部类。\n做个小实验：\n```java\nThreadLocal<Integer> iLocal = new ThreadLocal<Integer>();\niLocal.set(1);\niLocal.set(2);\n\nThreadLocal<String> sLocal = new ThreadLocal<String>();\nsLocal.set(\"a\");\nsLocal.set(\"b\");\n\nSystem.out.println(iLocal.get());\nSystem.out.println(sLocal.get());\n```\n输出结果是2，b。也可以看看这篇博客：\nhttp://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/\n\n### **DBUtils与ThreadLocal合并运用**\n刚刚说了要使用事务就必须保证链接是同一个，所以可以利用ThreadLocal来实现。\n一个转账小例子：\n\n开始转账：\n```java\npackage com.jyh.test;\n\nimport com.jyh.service.AccountService;\nimport com.jyh.service.impl.AccountServiceImpl2;\nimport com.jyh.utils.ServiceFactory;\n\npublic class test {\n\n	public static void main(String[] args) {\n		AccountService as2 = null;\n		try {\n			//从工厂里面获取实例，第一个参数为true说明是需要事务的\n			as2 = ServiceFactory.getService(true, AccountServiceImpl2.class);\n		} catch (Exception e) {\n			e.printStackTrace();\n		}\n		//ccc转账100给aaa\n		as2.transfer(\"ccc\", \"aaa\", 100);\n\n	}\n}\n```\n工厂类：\n```java\npackage com.jyh.utils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n/**\n * 工厂模式来决定service如何实现\n * @author OverrideRe\n *\n */\n\npublic class ServiceFactory {\n\n	public static <T> T getService(boolean isProxy,Class<T> clazz) throws Exception{\n		final T t = clazz.newInstance();\n		if(isProxy){//如果是true说明需要事务，那么对每个方法的调用都要用事务包起来\n			//代理模式监视每个方法\n			@SuppressWarnings(\"unchecked\")\n			T tt = (T)Proxy.newProxyInstance(t.getClass().getClassLoader(), t.getClass().getInterfaces(), new InvocationHandler() {\n				public Object invoke(Object proxy, Method method, Object[] args)\n						throws Throwable {\n					System.out.println(\"工厂模式里的代理模式\");\n					try {\n						//方法执行前开启事务\n						ThreadLocalUtil.startTransaction();\n						//方法执行\n						method.invoke(t, args);\n						//方法执行之后提交事务\n						ThreadLocalUtil.commit();\n					} catch (Exception e) {\n						//回滚事务\n						ThreadLocalUtil.rollBack();\n						throw new RuntimeException(e);\n					}finally{\n						//释放资源\n						ThreadLocalUtil.release();\n					}\n					return null;\n				}\n			});\n			return tt;\n		}\n		return t;\n	}\n}\n\n```\n\n获取链接的ThreadLocalUtil工具类：\n```java\npackage com.jyh.utils;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n\n@SuppressWarnings(\"rawtypes\")\npublic class ThreadLocalUtil extends ThreadLocal{\n	private static ThreadLocal<Connection> tl = new ThreadLocal<Connection>();\n	\n	public static Connection getConnection(){\n		Connection conn = tl.get();//获取线程中保存的链接\n		if(conn == null){//如果没有则创建一个链接set进去\n			conn = DBCPUtil.getConnection();\n			tl.set(conn);\n		}\n		return conn;\n	}\n	\n	//开启事务\n	public static void startTransaction(){\n		Connection conn = getConnection();\n		try {\n			conn.setAutoCommit(false);\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n	}\n	\n	//提交事务\n	public static void commit(){\n		Connection conn = getConnection();\n		try {\n			conn.commit();\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n	}\n	\n	//回滚事务\n	public static void rollBack(){\n		Connection conn = getConnection();\n		try {\n			conn.rollback();\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n	}\n	\n	//释放资源\n	public static void release(){\n		Connection conn = getConnection();\n		try {\n			conn.close();\n			tl.remove();//移除\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n	}\n\n}\n```\n\n业务逻辑类：\n```java\npackage com.jyh.service.impl;\n\nimport com.jyh.dao.AccountDao;\nimport com.jyh.dao.impl.AccountDaoImpl;\nimport com.jyh.domain.Account;\nimport com.jyh.service.AccountService;\n\npublic class AccountServiceImpl2 implements AccountService {\n	\n	private AccountDao ad = new AccountDaoImpl();\n\n	//实现用户转账\n	public void transfer(String sourceName, String targetName, Integer money) {\n		Account a = ad.query(sourceName);//获取a用户\n		Account b= ad.query(targetName);//获取b用户\n		\n		a.setSalary(a.getSalary() - money);//a用户减少这么多money\n		b.setSalary(b.getSalary() + money);//b用户增加这么多money\n		\n		//更新数据库\n		ad.update(a);\n		ad.update(b);\n	}\n\n}\n\n```\n\ndao实现类：\n```java\npackage com.jyh.dao.impl;\n\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\n\nimport com.jyh.dao.AccountDao;\nimport com.jyh.domain.Account;\nimport com.jyh.utils.ThreadLocalUtil;\n\npublic class AccountDaoImpl implements AccountDao {\n\n	//这里没有传递数据源\n	private QueryRunner qr = new QueryRunner();\n	\n	public AccountDaoImpl(){\n	}\n	\n	public void update(Account account) {\n		try {\n			//这里传递了一个链接，为了实现事务\n			qr.update(ThreadLocalUtil.getConnection(),\"update account set salary = ? where id = ?\", account.getSalary(),account.getId());\n		} catch (SQLException e) {\n			e.printStackTrace();\n		}\n	}\n\n	public Account query(String name) {\n		try {\n			return qr.query(ThreadLocalUtil.getConnection(), \"select * from account where name = ?\", new BeanHandler<Account>(Account.class),name);\n		} catch (SQLException e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n}\n\n```', null, '2017-03-13 14:26:54', '111', '0', 'JDBC,java', '0', '5', null, '1');
INSERT INTO `article` VALUES ('402881f25ac80e96015ac8112a1c0004', 'Filter过滤器和Listener监听器简述', 'Filter过滤器Filter的简介对资源的访问进行过滤，相当于小区的保安，进去要检查，出去还要检查。Filter的使用编写一个类，继承并实现javax.servlet.Filter。```javapackagecom.jyh.filter;importjava.io.IOException;importjavax.servlet.Filter;importjavax.servlet.Filter', '# **Filter过滤器**\n **Filter的简介**\n	对资源的访问进行过滤，相当于小区的保安，进去要检查，出去还要检查。\n\n **Filter的使用**\n\n1. 编写一个类，继承并实现javax.servlet.Filter。\n\n	```java\npackage com.jyh.filter;\n		import java.io.IOException;\n		import javax.servlet.Filter;\n		import javax.servlet.FilterChain;\n		import javax.servlet.FilterConfig;\n		import javax.servlet.ServletException;\n		import javax.servlet.ServletRequest;\n		import javax.servlet.ServletResponse;\n		\n		\n		public class FilterDemo1 implements Filter {\n		\n			private FilterConfig filterConfig;\n			\n			public FilterDemo1(){\n				System.out.println(\"实例化了\");\n			}\n			\n			//初始化\n			@Override\n			public void init(FilterConfig filterConfig) throws ServletException {\n				//通过这个获取过滤器在web.xml里面的配置信息\n				this.filterConfig = filterConfig;\n				System.out.println(\"过滤器初始化了\");\n			}\n		\n			//执行\n			@Override\n			public void doFilter(ServletRequest req, ServletResponse res,\n					FilterChain chain) throws IOException, ServletException {\n		\n				//获取在web.xml中本过滤器配置的名为encoding的参数\n				String encoding = filterConfig.getInitParameter(\"encoding\");\n				if(encoding == null){\n					encoding = \"UTF-8\";\n				}\n				//设置编码格式\n				req.setCharacterEncoding(encoding);\n				res.setContentType(\"text/html;charset=\" + encoding);\n				System.out.println(\"过滤前\");\n				//放行\n				chain.doFilter(req, res);\n				System.out.println(\"过滤后\");\n			}\n		\n			//销毁\n			@Override\n			public void destroy() {\n				System.out.println(\"过滤器销毁了\");\n			}\n		\n		}\n	```\n\n2.  在web.xml中配置Filter\n\n	```xml\n	<filter>\n	    <filter-name>FilterDemo1</filter-name>\n	    <filter-class>com.jyh.filter.FilterDemo1</filter-class>\n	    <!-- 配置参数 -->\n	    <init-param>\n	    	<param-name>encoding</param-name>\n	    	<param-value>UTF-8</param-value>\n	    </init-param>\n	  </filter>\n	  <filter-mapping>\n	    <filter-name>FilterDemo1</filter-name>\n	    <url-pattern>/*</url-pattern>\n	  </filter-mapping>\n	```\n过滤器是用来对访问进去过滤的，所以需要在请求前做什么和请求之后做什么都可以用过滤器来做，例如编码的设置，自动登录等。串联过滤器什么的听着就知道是什么情况了。\n\n#Listener监听器\n\n- 编写一个类继承实现以下监听器接口。\n\n1. 监听ServletContext、HttpSession、ServletRequest对象的创建和销毁的监听器\n\n	ServletContextListener:\n	HttpSessionListener:\n	SerlvetRequestListener:\n\n2. 监听ServletContext、HttpSession、ServletRequest属性(attributes)变化的监听器\n\n	ServletContextAttributeListener\n	HttpSessionAttributeListener\n	SerlvetRequestAttributeListener\n\n3. 感知型监听器：不需要注册。\n\n	HttpSessionBindingListener：实现该接口的类的实例，能够感知自己何时被放到了HttpSession域范围中，和何时从HttpSession域范围中删除。\n	\n	HttpSessionActivationListener：实现该接口的类的实例，能够感知自己何时随着HttpSession钝化和激活。\n\n- 在web.xml配置一下\n\n	```xml\n	  <listener>\n		  <!-- 指向自己缩写的监听器类 -->\n	  	<listener-class>com.jyh.listener.MyContextListener</listener-class>\n	  </listener>\n	```', null, '2017-03-13 14:27:33', '111', '0', 'java,filter,listener', '0', '3', null, '1');
INSERT INTO `article` VALUES ('402881f25ac80e96015ac81198600007', 'Struts2学习之1(Struts2的工作流程，动作类的编写，struts.xml配置文件的编写)', 'Struts2的开始Struts2的作用现在项目一般都是按照三层架构来开发的，表现层，业务逻辑层，数据访问层，Struts2就是用来代替servlet处理表现层的一种框架，用来处理页面的请求跳转与数据显示等，Struts2里面还是用servlet来实现的，只不过被高度封装了。搭建Struts2开发环境下载jar包从官网http://struts.apache.org/上下载所需要的jar包拷贝ja', '# **Struts2的开始**\n## **Struts2的作用**\n现在项目一般都是按照三层架构来开发的，表现层，业务逻辑层，数据访问层，Struts2就是用来代替servlet处理表现层的一种框架，用来处理页面的请求跳转与数据显示等，Struts2里面还是用servlet来实现的，只不过被高度封装了。\n## **搭建Struts2开发环境**\n### **下载jar包**\n从官网http://struts.apache.org/上下载所需要的jar包\n### **拷贝jar包到项目中去**\n打开Struts2发行包\\apps\\struts2-blank\\WEB-INF\\lib,把其中jar都拷贝过来即可。\n### **编写配置文件**\n在构建路径的顶端，创建一个配置文件struts.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE struts PUBLIC\n	\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n	\"http://struts.apache.org/dtds/struts-2.3.dtd\">\n\n<struts>\n\n</struts>\n```\n声明部分可以拷贝struts-core-xxx.jar中的struts-default.xml里的头部声明。\n### **配置控制映射**\n在项目的web.xml中配置如下信息\n```xml\n <!-- 配置Struts2框架的核心控制器 -->\n  <filter>\n  	<filter-name>struts2</filter-name>\n  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n  </filter>	\n  <filter-mapping>\n  	<filter-name>struts2</filter-name>\n  	<url-pattern>/*</url-pattern>\n  </filter-mapping>\n```\n## **开始一个小例子**\n### **页面编写**\n```html\n<body>\n    <a href=\"${pageContext.request.contextPath}/uuu/helloWorld.action\">点击</a>\n  </body>\n```\n### **配置文件编写**\n```xml\n<struts>\n	<!-- name为包名，唯一的； namespace为命名空间，先找到namespace，找到了就在当前namespace下找action，找不到action则在默认的namespace下找action，extends是继承某个包，默认写struts-default，该包可以在struts-default.xml中找到 -->\n	<package name=\"p1\" extends=\"struts-default\" namespace=\"/uuu\">\n		<!-- name为请求链接名(动作名称)，class为请求的类全名，默认为com.opensymphony.xwork2.ActionSupport\n		method为请求类里的处理方法，默认为execute() -->\n		<action name=\"helloWorld\" class=\"com.jyh.action.HelloWorldAction\" method=\"sayHello\">\n			<!-- result为返回的页面 -->\n			<result name=\"success\">/success.jsp</result>\n			<result name=\"error\">/error.jsp</result>\n		</action>\n	</package>\n</struts>\n```\n### **动作类编写**\n```java\npackage com.jyh.action;\n\npublic class HelloWorldAction {\n\n	public String sayHello(){\n		return \"success\";\n	}\n}\n\n```\n### **结果视图编写**\n创建success.jsp和error.jsp\n### **案例执行过程简析**\n页面点击发送请求，由web.xml配置文件中配置的struts拦截器拦截，读取struts中的配置，先找到namespace，然后在对应的namespace下找到action，然后到action中class指向的类中找到method指向的方法，返回的字符串与result中的name属性匹配，然后跳转到结果页面。页面中的链接就是：当前项目路径/namespace/action.name。\n![struts的执行过程图](http://img.blog.csdn.net/20170117123622163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n# **动作类**\n## **动作类的三种编写方式**\n### **方式一**\n如上图所示，直接编写一个普通的类\n### **方式二**\n实现com.opensymphony.xwork2.Action接口\n```java\npackage com.jyh.action;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\n@SuppressWarnings(\"serial\")\npublic class Demo1 extends ActionSupport {\n\n	public String execute() throws Exception {\n		return SUCCESS;\n	}\n\n	\n}\n\n```\nAction接口中的常量：\nString SUCCESS:success。一切正常。\nString NONE:none。动作方法执行后，不转向任何的结果视图。或者在动作方法中返回null。\nString ERROR:error。动作方法执行时遇到异常，转向错误提示页面。\nString INPUT：input。验证、转换失败，转向输入页面。\nString LOGIN：login。检测用户是否登录，没有登录转向此视图。\n\n### **方式三**\n继承com.opensymphony.xwork2.ActionSupport（推荐）\n意义：提供了一些基本的功能。比如验证和国际化消息提示等。\n### **动作类中动作方法的编写**\npublic String xxx(){};\n## **动作类的通配符映射**\n```xml\n<!-- name中的*号代表定义一个通配符，页面的链接与name属性匹配代表给通配符*赋值，如页面中链接为addCustomerUI\n		则表示第一个*为add，第二个*为UI，后面的{1}代表引用第一个统配符号，以*在name属性出现的顺序为序号来引用，\n		所以可以看成method=\"add\"，result转向页面为/customer/UICustomer.jsp -->\n		<action name=\"*Customer*\" class=\"com.jyh.action.CustomerAction\" method=\"{1}\">\n			<result name=\"success\">/customer/{2}Customer.jsp</result>\n		</action>\n```\n## **动态方法调用:DMI（Dynamic Method Invocation）**\n在访问时指定执行的动作方法：\nhttp://localhost:8080/XXX/demo4!m1 执行demo4动作对应动作类的m1动作方法\n默认情况下：会报错，说找不到demo4!m1这个动作方法。因为struts2框架默认是禁止动态方法调用的。\n` <constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\">`\n注意：不建议使用。容易暴露动作类中的动作方法，害怕非法执行。\n\n## **动作类获取ServletAPI**\n### **方式一（推荐）**\n```java\npackage com.jyh.action;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.struts2.ServletActionContext;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\n@SuppressWarnings(\"serial\")\npublic class ServletAction extends ActionSupport {\n\n	@Override\n	public String execute() throws Exception {\n		HttpServletRequest request = ServletActionContext.getRequest();\n		HttpServletResponse response = ServletActionContext.getResponse();\n		ServletContext context = ServletActionContext.getServletContext();\n		System.out.println(request);\n		System.out.println(response);\n		System.out.println(context);\n		return null;\n	}\n}\n\n```\n### **方式二**\n```java\npackage com.jyh.action;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.struts2.interceptor.ServletRequestAware;\nimport org.apache.struts2.interceptor.ServletResponseAware;\nimport org.apache.struts2.util.ServletContextAware;\n\npublic class ServletAction2 implements ServletRequestAware,ServletResponseAware,ServletContextAware {\n	\n	/**\n	 * 拦截器注入的这些东西(servletConfig拦截器)\n	 */\n	private HttpServletRequest request;\n	private HttpServletResponse response;\n	private ServletContext context;\n	\n	public String execute() throws Exception {\n		\n		System.out.println(request);\n		System.out.println(response);\n		System.out.println(context);\n		return null;\n	}\n\n	public void setServletResponse(HttpServletResponse response) {\n		this.response = response;\n	}\n\n	public void setServletRequest(HttpServletRequest request) {\n		this.request = request;\n	}\n\n	public void setServletContext(ServletContext context) {\n		this.context = context;\n	}\n\n}\n\n```\n# **Struts2配置文件struts.xml**\n## **Struts2的其它一些配置文件和写法**\n### **自带的一些配置文件**\n1. default.properties:struts2-core**.jar org.apache.struts包中（只读）\n2. struts-default.xml：struts2-core**.jar中（只读）\n3. struts-plugin.xml:在插件的jar包中（只读）\n4. struts.xml：在应用的构建路径顶端。自己定义的Struts配置文件（推荐）\n5. struts.properties:在应用的构建路径顶端。自己编写（不推荐）\n6. web.xml:配置过滤器时，指定参数。自己编写（不推荐）\n特别注意：顺序是固定的。后面的配置会覆盖前面的同名配置信息。\n### **一些常用的默认参数的修改与设置**\n包含其他配置文件\n`<include file=\"user.xml\"></include>`\n```xml\n<!-- 修改链接默认后缀，多个后缀可以用逗号隔开 -->\n	<constant name=\"struts.action.extension\" value=\"do\"></constant>\n	<!-- 设置浏览器是否缓存静态内容，默认值为true -->\n	<constant name=\"struts.serve.static.browserCache\" value=\"false\"></constant>\n	<!-- 当struts的配置文件修改后系统是否自动重新加载该文件，默认值为false，推荐打开 -->\n	<constant name=\"struts.configuration.xml.reload\" value=\"true\"></constant>\n	<!-- 开发模式，会非常详细的打印出一些错误信息，开启它则默认开启了i18n.reload、configuration.xml.reload。  -->\n	<constant name=\"struts.devMode\" value=\"true\"></constant>\n	<!-- 视图主题(simple,xhtml,css_xhtml)，默认为xhtml，也就是struts2自带的视图主题，simple为不普通的标签不带任何主题 -->\n	<constant name=\"struts.ui.theme\" value=\"simple\"></constant>\n	<!-- 与spring集成时，指定由spring负责action对象的创建 -->\n	<constant name=\"struts.objectFactory\" value=\"spring\"></constant>\n	<!-- 该属性设置struts是否支持动态方法调用，默认为false-->\n	<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"></constant>\n	<!-- 上传文件大小限制 -->\n	<constant name=\"struts.multipart.maxSize\" value=\"100000000\"></constant>\n```\n## **package元素**\n意义：分模块开发。\n属性：\n- name:必须的。配置文件中要唯一。就是一个名字。\n- extends:指定父包。会把父包中的配置内容继承下来。一般需要直接或间接的继承一个叫做“struts-default”的包(在struts-default.xml配置文件中)。如果不继承该包，那么Struts2中的核心功能将无法使用。\n- abstract：是否是抽象包。没有任何action子元素的package可以声明为抽象包。\n- namespace：指定名称空间。一般以”/”开头。该包中的动作访问路径：namesapce+动作名称。如果namespace=””，这是默认名称空间，和不写该属性是一样的。\n## **action元素**\n作用：定义一个动作。\n属性：\n- name：必须的。动作名称。用户用于发起请求。在包中要唯一。\n- class：指定动作类的全名。框架会通过反射机制实例化。默认是：com.opensymphony.xwork2.ActionSupport。\n- method：指定动作类中的动作方法。框架会执行该方法。默认是execute()。\n默认类在struts-default.xml中声明了，也可以用\n	` <default-class-ref class=\"完整类名\"></default-class-ref>`覆盖\n\n## **结果视图result元素**\n- name：逻辑视图名称。它对应的是动作方法的返回值。默认值：success。\n- type：结果类型，到达目标的形式。默认值：dispatcher-转发。\n\n- 全局视图：` <global-results></global-results>`，直接写在包下\n- 局部视图：`<results></global> `，写在action下\n在什么下范围就多大，先找action下的局部视图（范围精确），再找报下的全局视图\n\n### **默认拥有的结果类型(result的type元素)**\nstruts-default.xml中定义的结果视图\n```xml\n<result-types>\n            <result-type name=\"chain\" class=\"com.opensymphony.xwork2.ActionChainResult\"/>\n            <result-type name=\"dispatcher\" class=\"org.apache.struts2.dispatcher.ServletDispatcherResult\" default=\"true\"/>\n            <result-type name=\"freemarker\" class=\"org.apache.struts2.views.freemarker.FreemarkerResult\"/>\n            <result-type name=\"httpheader\" class=\"org.apache.struts2.dispatcher.HttpHeaderResult\"/>\n            <result-type name=\"redirect\" class=\"org.apache.struts2.dispatcher.ServletRedirectResult\"/>\n            <result-type name=\"redirectAction\" class=\"org.apache.struts2.dispatcher.ServletActionRedirectResult\"/>\n            <result-type name=\"stream\" class=\"org.apache.struts2.dispatcher.StreamResult\"/>\n            <result-type name=\"velocity\" class=\"org.apache.struts2.dispatcher.VelocityResult\"/>\n            <result-type name=\"xslt\" class=\"org.apache.struts2.views.xslt.XSLTResult\"/>\n            <result-type name=\"plainText\" class=\"org.apache.struts2.dispatcher.PlainTextResult\" />\n        </result-types>\n```\n1. freemarker：用于转发到另外一个freemarker模板。（页面静态化）\n2. velocity：用于转发到另外一个velocity模板。\n3. httpheader：用于输出http协议的消息头。\n4. xslt：XML有关的样式\n5. redirect：用于重定向到另外一个JSP页面。\n6. redirectAction：用于重定向到另外一个动作。\n7. stream：用于文件下载（日后再讲。文件上传和下载）\n8. plainText：以纯文本的形式展现页面。输出源码。\n9. chain:用户转发到另外一个动作。\n10. dispatcher：用于转发到另外一个JSP页面。\n```xml\n<!-- 同一个包下一个动作转发到另一个动作 -->\n	<package name=\"d1\" extends=\"struts-default\" namespace=\"/n1\">\n		<action name=\"demo1\" class=\"com.jyh.action.Demo1\" method=\"execute\">\n			<result name=\"success\" type=\"chain\">demo2</result>\n		</action>\n		<action name=\"demo2\" class=\"com.jyh.action.Demo1\" method=\"execute\">\n			<!-- <result name=\"success\" type=\"dispatcher\">/demo1.jsp</result> -->\n			<!-- 同上，dispatcher表示转发到页面 -->\n			<result name=\"success\" type=\"dispatcher\">\n				<param name=\"location\">/demo1.jsp</param>\n			</result>\n		</action>\n	</package>\n	<!-- 转发到另一个包中的动作 -->\n	<package name=\"d2\" extends=\"struts-default\" namespace=\"/n2\">\n		<action name=\"demo3\" class=\"com.jyh.action.Demo1\" method=\"execute\">\n			<result name=\"success\" type=\"chain\"><!-- 配置type=\"chain\"意思是从这个动作跳到另一个动作 -->\n				<param name=\"namespace\">/n1</param><!-- 配置转发目标动作所在的命名空间 -->\n				<param name=\"actionName\">demo2</param><!-- 配置转发目标动作的名称 -->\n			</result>\n		</action>\n	</package>\n```\n### **自定义结果类型(result的type元素)**\n1.编写一个类，直接或间接实现com.opensymphony.xwork2.Result接口。一般继承org.apache.struts2.dispatcher.StrutsResultSupport类\n\n	```java\n	package com.jyh.action;\n	\n	/**\n	 * 自定义结果类型，生成验证码\n	 */\n	import java.awt.image.BufferedImage;\n	\n	import javax.imageio.ImageIO;\n	import javax.servlet.http.HttpServletResponse;\n	\n	import org.apache.struts2.ServletActionContext;\n	import org.apache.struts2.dispatcher.StrutsResultSupport;\n	\n	import cn.dsna.util.images.ValidateCode;\n	\n	import com.opensymphony.xwork2.ActionInvocation;\n	\n	@SuppressWarnings(\"serial\")\n	public class CaptchaResult extends StrutsResultSupport {\n	\n		private int width = 200;//长度\n		private int height = 80;//宽度\n		private int codeCount = 4;//验证码个数\n		private int lineCount = 100;//干扰线条数\n		\n		public void setWidth(int width) {\n			this.width = width;\n		}\n	\n		public void setHeight(int height) {\n			this.height = height;\n		}\n	\n		public void setCodeCount(int codeCount) {\n			this.codeCount = codeCount;\n		}\n	\n		public void setLineCount(int lineCount) {\n			this.lineCount = lineCount;\n		}\n	\n		protected void doExecute(String finalLocation, ActionInvocation invocation)\n				throws Exception {\n			ValidateCode vCode = new ValidateCode(width, height, codeCount, lineCount);\n			BufferedImage image = vCode.getBuffImg();\n			HttpServletResponse response = ServletActionContext.getResponse();\n			ImageIO.write(image, \"jpeg\", response.getOutputStream());\n		}\n	\n	}\n	\n	```\n2.声明定义结果类型\n```xml\n<!-- 自定义结果类型 -->\n<package name=\"d3\" extends=\"struts-default\">\n	<!-- 声明定义结果类型 -->\n	<result-types>\n		<!-- name为结果类型名称，class为具体实现的类 -->\n		<result-type name=\"captcha\" class=\"com.jyh.action.CaptchaResult\"/>\n	</result-types>\n</package>\n```\n3.使用自定义的结果类型\n```xml\n<action name=\"captcha\">\n	<!-- 使用定义的结果类型 -->\n	<result name=\"success\" type=\"captcha\">\n		<!-- 设置结果类型对应的实现类中的属性 -->\n		<param name=\"width\">200</param>\n		<param name=\"height\">80</param>\n		<param name=\"codeCount\">4</param>\n		<param name=\"lineCount\">100</param>\n	</result>\n</action>\n```\n\n', null, '2017-03-13 14:28:01', '111', '0', 'struts2,java', '0', '3', null, '1');
INSERT INTO `article` VALUES ('402881f25ac80e96015ac812022b000a', 'Struts2学习之2(请求参数的封装，类型转换，输入验证，自定义拦截器)', '封装请求参数动态参数注入（请求参数，用户输入的）方式一（动作类作为模型）页面&lt;formaction=\"${pageContext.request.contextPath}/q1/login.do\"method=\"post\"&gt;&lt;!--name属性对应着动作类中的属性--&gt;UserName:&lt;inputname=\"userName\"type=\"text\"/&gt;&lt;', '# **封装请求参数**\n## **动态参数注入（请求参数，用户输入的）**\n### **方式一（动作类作为模型）**\n- 页面\n```html\n<form action=\"${pageContext.request.contextPath}/q1/login.do\" method=\"post\">\n	<!-- name属性对应着动作类中的属性-->\n   	UserName:<input name=\"userName\" type=\"text\"/><br/>\n   	Password:<input name=\"password\" type=\"password\"/><br/>\n   	<input type=\"submit\" value=\"登录\"/>\n</form>\n```\n- 动作类\n```java\npackage com.jyh.action;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\n@SuppressWarnings(\"serial\")\npublic class UserAction extends ActionSupport {\n\n	//编写与表单里面名字相同的私有属性并提供相应的getset方法\n	private String userName;\n	private String password;\n	public void setUserName(String userName) {\n		this.userName = userName;\n	}\n	public void setPassword(String password) {\n		this.password = password;\n	}\n	public String getUserName() {\n		return userName;\n	}\n	public String getPassword() {\n		return password;\n	}\n	public String login(){\n		System.out.println(userName + \":\" + password);\n		if(\"jyh\".equals(userName) && \"123\".equals(password))\n			return SUCCESS;\n		return ERROR;\n	}\n}\n\n```\n### **方式二（动作类和模型分开）**\n- 页面\n```html\n<form action=\"${pageContext.request.contextPath}/q2/login.do\" method=\"post\">\n	<!-- name属性中person代表着动作类中模型对象的实例 -->\n   	UserName:<input name=\"person.userName\" type=\"text\"/><br/>\n   	Password:<input name=\"person.password\" type=\"password\"/><br/>\n   	<input type=\"submit\" value=\"登录\"/>\n</form>\n```\n- 动作类\n```java\npackage com.jyh.action;\n\nimport com.jyh.domain.Person;\nimport com.opensymphony.xwork2.ActionSupport;\n\n@SuppressWarnings(\"serial\")\npublic class PersonAction extends ActionSupport {\n\n	private Person person = new Person();\n\n	public Person getPerson() {\n		return person;\n	}\n\n	public void setPerson(Person person) {\n		this.person = person;\n	}\n	public String login(){\n		System.out.println(person);\n		if(\"jyh\".equals(person.getUserName()) && \"123\".equals(person.getPassword()))\n			return SUCCESS;\n		return ERROR;\n	}\n}\n\n```\n### **方式三（动作类和模型分开，使用ModelDriven<T>模型驱动）**\n- 页面\n```html\n<form action=\"${pageContext.request.contextPath}/q3/login.do\" method=\"post\">\n   	UserName:<input name=\"userName\" type=\"text\"/><br/>\n   	Password:<input name=\"password\" type=\"password\"/><br/>\n   	<input type=\"submit\" value=\"登录\"/>\n</form>\n```\n- 动作类\n```java\npackage com.jyh.action;\n\nimport com.jyh.domain.Person;\nimport com.opensymphony.xwork2.ActionSupport;\nimport com.opensymphony.xwork2.ModelDriven;\n\n@SuppressWarnings(\"serial\")\npublic class PersonAction2 extends ActionSupport implements ModelDriven<Person>{\n\n	private Person person = new Person();\n\n	public String login(){\n		System.out.println(person);\n		if(\"jyh\".equals(person.getUserName()) && \"123\".equals(person.getPassword()))\n			return SUCCESS;\n		return ERROR;\n	}\n\n	@Override\n	public Person getModel() {\n		return person;\n	}\n}\n\n```\n模型就是JavaBean模型类，该功能是由modelDriven拦截器完成的，与struts2的值栈有关。\n## **静态参数注入**\n就是在struts.xml配置文件中的action下面配置参数` <param name=\"name\">名字</param>`，\n然后就给动作类对应的属性赋值了。\n\n参数注入是由两个拦截器来完成。\n静态参数注入：staticParams\n动态参数注入：params \n\n# **自定义类型转换**\n## **编写类型转换实现类**\n```java\npackage com.jyh.convertors;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Map;\n\nimport org.apache.struts2.util.StrutsTypeConverter;\n//1、实现MM/dd/yyyy<------>java.util.Date互相转换\n@SuppressWarnings(\"all\")\npublic class MyDateConverter extends StrutsTypeConverter {\n	\n	private DateFormat df = new SimpleDateFormat(\"MM/dd/yyyy\");\n	//String--->其他类型：Date\n	/**\n	 * String[] values:用户输入的值.\n	 * Class toClass:目标类型\n	 */\n	public Object convertFromString(Map context, String[] values, Class toClass) {\n		if(toClass!=Date.class){\n			throw new RuntimeException(\"您转换的不是日期,请选择别的转换器\");\n		}\n		if(values==null||values.length==0)\n			throw new IllegalArgumentException(\"没有数据\");\n		String sDate = values[0];//用户输入的是\"\"\n		if(!sDate.trim().equals(\"\")){\n			try {\n				return df.parse(sDate);\n			} catch (ParseException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return null;\n	}\n	//其他类型：Date---->String\n	/**\n	 * Object o:对象\n	 */\n	public String convertToString(Map context, Object o) {\n		if(!(o instanceof Date)){\n			throw new RuntimeException(\"您的数据不是日期,请选择别的转换器\");\n		}\n		Date date = (Date)o;\n		return df.format(date);\n	}\n\n}\n\n```\n## **声明定义配置**\n### **局部类型转换器，为某个类的某个属性字段进行验证**\n- 动作和模型分开\n配置文件放在模型类所在包，文件名为：模型类名-conversion.properties\n![这里写图片描述](http://img.blog.csdn.net/20170117165230782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n- 动作和模型不分开\n配置文件放在动作类所在包，文件名为：动作类名-conversion.properties\n### **全局转换器，为某个类型进行验证**\n配置文件放在构建路径顶端，文件名为：xwork-conversion.properties，里面一般是需要验证的类型对应自定义的转换器，比如java.util.Date=com.jyh.convertors.MyDateConverter。\n## **转换失败之后的提示**\n1. 转换失败，会自动转到一个name=input的逻辑视图，一般指向输入的那个页面，目的回显（建议使用struts2的表单标签）\n2. 错误消息提示中文版本\n前提：动作类继承ActionSupport才能使用。\n文件名为：类名.properties\n![这里写图片描述](http://img.blog.csdn.net/20170117170312829?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n总结就是转换器配置文件名为：需要验证的属性所在类的类名-conversion.properties\n中文提示信息的配置文件名为：被验证的属性所在类的类名.properties\n# **输入验证**\n## **编程式验证**\n缺点：验证规则写到了代码中，硬编码。\n优点：验证时可以控制的更加精细。（用的少）\n### **针对所有方法进行验证**\n1.动作类需要实现ActionSupport,覆盖掉public void validate(){}方法,\n2.方法内部：编写你的验证规则，不正确的情况调用addFieldError添加错误信息\n```java\npublic void validate() {\n	if(\"\".equals(student.getUsername())){\n		addFieldError(\"username\", \"请输入用户名\");\n	}\n}\n```\n使用username这种方式添加错误信息s:fieldError标签中和普通标签中都有错误提示消息,使用了,将只会在s:fieldError中显示错误消息\n3.验证失败：\n视图：会自动转向一个name=input的逻辑视图\n错误消息提示：建议使用struts2标签库。如果没有显示请使用s:fieldError标签\n\n### **针对指定的方法进行验证**\n#### **方式一**\n在指定方法前面添加一个注解：@SkipValidation，有该注解的方法就不会进行验证\n#### **方式二**\n在需要验证的方法，编写一个方法，命名为validate+需要验证的方法名，需要验证的方法名首字母需要大写，如：如果一个动作方法名叫做regist，只针对该方法进行验证，就编写public void validateRegist(){}；\n![这里写图片描述](http://img.blog.csdn.net/20170117172114791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## **声明式验证**\n优点：把验证规则写到了配置文件中。（用得多）\n缺点：不是很精细。\n错误视图和消息提示和编程式一致。\n### **针对所有方法进行验证**\n在动作类所在的包中建立：动作类名-validation.xml配置文件。\n头部声明可以在struts包/xwork-core-xxx.jar/xwork-validator-xxx.dtd中找到，该dtd文件就是验证配置文件的约束。\n\n### **针对指定的方法进行验证**\n文件名改为：动作类名-动作名（struts.xml中action的name属性）-validation.xml\n\n说明：验证功能是由validation拦截器来负责处理的。回显错误信息是由workflow拦截器来负责处理的。\n\n### **struts2中提供的内置声明式验证器的使用**\nStruts2提供的声明式验证器在xwork-core-**.jar包的\ncom.opensymphony.xwork2.validator.validators.default.xml配置文件中。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE validators PUBLIC\n        \"-//Apache Struts//XWork Validator Definition 1.0//EN\"\n        \"http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd\">\n\n<!-- START SNIPPET: validators-default -->\n<validators>\n    <validator name=\"required\" class=\"com.opensymphony.xwork2.validator.validators.RequiredFieldValidator\"/>\n    <validator name=\"requiredstring\" class=\"com.opensymphony.xwork2.validator.validators.RequiredStringValidator\"/>\n    <validator name=\"int\" class=\"com.opensymphony.xwork2.validator.validators.IntRangeFieldValidator\"/>\n    <validator name=\"long\" class=\"com.opensymphony.xwork2.validator.validators.LongRangeFieldValidator\"/>\n    <validator name=\"short\" class=\"com.opensymphony.xwork2.validator.validators.ShortRangeFieldValidator\"/>\n    <validator name=\"double\" class=\"com.opensymphony.xwork2.validator.validators.DoubleRangeFieldValidator\"/>\n    <validator name=\"date\" class=\"com.opensymphony.xwork2.validator.validators.DateRangeFieldValidator\"/>\n    <validator name=\"expression\" class=\"com.opensymphony.xwork2.validator.validators.ExpressionValidator\"/>\n    <validator name=\"fieldexpression\" class=\"com.opensymphony.xwork2.validator.validators.FieldExpressionValidator\"/>\n    <validator name=\"email\" class=\"com.opensymphony.xwork2.validator.validators.EmailValidator\"/>\n    <validator name=\"url\" class=\"com.opensymphony.xwork2.validator.validators.URLValidator\"/>\n    <validator name=\"visitor\" class=\"com.opensymphony.xwork2.validator.validators.VisitorFieldValidator\"/>\n    <validator name=\"conversion\" class=\"com.opensymphony.xwork2.validator.validators.ConversionErrorFieldValidator\"/>\n    <validator name=\"stringlength\" class=\"com.opensymphony.xwork2.validator.validators.StringLengthFieldValidator\"/>\n    <validator name=\"regex\" class=\"com.opensymphony.xwork2.validator.validators.RegexFieldValidator\"/>\n    <validator name=\"conditionalvisitor\" class=\"com.opensymphony.xwork2.validator.validators.ConditionalVisitorFieldValidator\"/>\n</validators>\n<!--  END SNIPPET: validators-default -->\n\n```\n验证配置文件写法：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE validators PUBLIC\n  		\"-//Apache Struts//XWork Validator 1.0.3//EN\"\n  		\"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\">\n<validators>\n	<!-- field指定要验证的字段，name是字段名。和表单一致 -->\n	<field name=\"username\">\n		<!-- 必须由3~8位字母组成-->\n		<field-validator type=\"regex\"><!-- type为验证类型，也就是验证器的名字 -->\n			<param name=\"regexExpression\"><![CDATA[[a-zA-Z]{3,8}]]></param><!-- param是指定验证器的属性参数 -->\n			 <message>你的名字必须由3~8位字母组成</message><!-- message是返回的错误信息 -->\n		</field-validator>\n	</field>\n	<!-- 验证密码必须3~8位数字组成：换一种 -->\n	<!-- \n	<validator type=\"regex\">\n		<param name=\"fieldName\">password</param>\n		<param name=\"regexExpression\"><![CDATA[\\d{3,8}]]></param>\n		 <message>你的密码必须由3~8位数字组成</message>\n	</validator>\n	 -->\n	 <field name=\"password\">\n	 	<field-validator type=\"requiredstring\">\n	 		<message>请输入密码</message>\n	 	</field-validator>\n	 	<field-validator type=\"strongpassword\">\n	 		<message>你的密码必须由大小写字母和数字组成</message>\n	 	</field-validator>\n	 </field>\n	<!-- 必须选择性别 -->\n	<field name=\"gender\">\n		<field-validator type=\"required\">\n			 <message>请选择性别</message>\n		</field-validator>\n	</field>\n	<field name=\"email\">\n		<field-validator type=\"email\">\n			 <message>请输入正确的邮箱</message>\n		</field-validator>\n	</field>\n</validators>\n```\n### **自定义声明式验证**\n验证密码的强度：至少一个大写、小写、数字组成。\n![这里写图片描述](http://img.blog.csdn.net/20170117174906421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTmljb3J1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n1.验证的实现:编写一个类，继承FieldValidatorSupport。\n\n```java\npackage com.jyh.validators;\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;\n\npublic class StrongPasswordValidator extends FieldValidatorSupport {\n	private boolean trim = true;\n\n	public boolean isTrim() {\n		return trim;\n	}\n\n	public void setTrim(boolean trim) {\n		this.trim = trim;\n	}\n\n	// Object object:当前执行的动作类\n	public void validate(Object object) throws ValidationException {\n		String fieldName = getFieldName();// 当前要验证的字段名\n		Object value = this.getFieldValue(fieldName, object);// 获取用户输入的值\n		if (!(value instanceof String)) {\n			addFieldError(fieldName, object);\n		} else {\n			String s = (String) value;\n\n			if (trim) {\n				s = s.trim();\n			}\n\n			if (!isPasswordStrong(s)) {\n				addFieldError(fieldName, object);\n			}\n		}\n	}\n\n	private static final String GROUP1 = \"abcdefghijklmnopqrstuvwxyz\";\n	private static final String GROUP2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n	private static final String GROUP3 = \"0123456789\";\n\n	protected boolean isPasswordStrong(String password) {\n		boolean ok1 = false;\n		boolean ok2 = false;\n		boolean ok3 = false;\n		int length = password.length();\n		for (int i = 0; i < length; i++) {\n			if (ok1 && ok2 && ok3)\n				break;\n			String character = password.substring(i, i + 1);\n			if (GROUP1.contains(character)) {\n				ok1 = true;\n				continue;\n			}\n			if (GROUP2.contains(character)) {\n				ok2 = true;\n				continue;\n			}\n			if (GROUP3.contains(character)) {\n				ok3 = true;\n				continue;\n			}\n		}\n		return ok1 && ok2 && ok3;\n	}\n}\n\n```\n2.验证的声明:在构建路径顶端，建立一个固定名称为validators.xml的配置文件,配置文件参考\nxwork-core-xxx.jar包的com.opensymphony.xwork2.validator.validators.default.xml。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE validators PUBLIC\n        \"-//Apache Struts//XWork Validator Definition 1.0//EN\"\n        \"http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd\">\n<validators>\n	<!-- name为验证器的名字，class为验证器的实现类 -->\n    <validator name=\"strongpassword\" class=\"com.jyh.validators.StrongPasswordValidator\"/>\n</validators>\n```\n3.验证器的使用\n```xml\n<field name=\"password\">\n	 	<field-validator type=\"requiredstring\">\n	 		<message>请输入密码</message>\n	 	</field-validator>\n	 	<!-- type为验证器的name属性 -->\n	 	<field-validator type=\"strongpassword\">\n	 		<message>你的密码必须由大小写字母和数字组成</message>\n	 	</field-validator>\n	 </field>\n```\n# **自定义拦截器**\n## **编写一个类，继承AbstractInterceptor抽象类或者MethodFilterInterceptor抽象类**\n```java\npackage com.jyh.interceptors;\n\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;\n\n@SuppressWarnings(\"serial\")\n//继承MethodFilterInterceptor可以有选择的进行拦截与不拦截\npublic class Demo1Interceptor extends MethodFilterInterceptor/*AbstractInterceptor*/{\n\n	public String doIntercept(ActionInvocation invocation) throws Exception {\n		System.out.println(\"拦截前\");\n		String valueString = invocation.invoke();//放行\n		System.out.println(\"拦截后\");\n		return valueString;\n	}\n\n}\n\n```\n## **声明定义与使用自定义拦截器**\n```xml\n	<!-- 定义一个包，用来进行拦截器的定义初始化 -->\n	<package name=\"myDefaultPackage\" extends=\"struts-default\">\n		<!-- 声明定义拦截器 -->\n		<interceptors>\n			<!-- 拦截器名和其实现类 -->\n			<interceptor name=\"demo1Interceptor\" class=\"com.jyh.interceptors.Demo1Interceptor\"></interceptor>\n			<!-- 定义一个拦截器栈 -->\n			<interceptor-stack name=\"mydefault\">\n				<!-- 包含默认的defaultStack栈 -->\n				<interceptor-ref name=\"defaultStack\"></interceptor-ref>\n				<!-- 包含自己定义的拦截器 -->\n				<interceptor-ref name=\"demo1Interceptor\"></interceptor-ref>\n			</interceptor-stack>\n		</interceptors>\n		\n		<!-- 覆盖默认的拦截器栈 -->\n		<default-interceptor-ref name=\"mydefault\"></default-interceptor-ref>\n	</package>\n	\n	<!-- 继承刚刚定义的包 -->\n	<package name=\"demo\" extends=\"myDefaultPackage\" namespace=\"/demo\">\n		<action name=\"demo1\" class=\"com.jyh.action.Demo1Action\" method=\"add\">\n			<!-- 使用拦截器，将会 覆盖所有默认拦截器 -->\n			<interceptor-ref name=\"demo1Interceptor\">\n				<!-- 添加参数excludeMethods代表不拦截，后面为不拦截的方法名(当前访问的方法名)\n				includeMethods代表拦截 -->\n				<param name=\"excludeMethods\">add</param>\n			</interceptor-ref>\n			<result name=\"success\">/demo1.jsp</result>\n		</action>\n		\n		<action name=\"demo2\" class=\"com.jyh.action.Demo1Action\" method=\"del\">\n			<!-- 使用拦截器栈，将会 覆盖所有默认拦截器，但是因为继承了默认的拦截器栈，所以保存了默认的拦截器 -->\n			<interceptor-ref name=\"mydefault\"></interceptor-ref>\n			<result name=\"success\">/demo1.jsp</result>\n		</action>\n	</package>\n```', null, '2017-03-13 14:28:28', '111', '0', 'java,struts2', '0', '3', null, '1');

-- ----------------------------
-- Table structure for article_class
-- ----------------------------
DROP TABLE IF EXISTS `article_class`;
CREATE TABLE `article_class` (
  `ca_id` varchar(255) NOT NULL,
  `cl_id` varchar(255) DEFAULT NULL,
  `ar_id` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ca_id`),
  KEY `article_foreign` (`ar_id`),
  KEY `pc_foreign` (`cl_id`),
  CONSTRAINT `article_foreign` FOREIGN KEY (`ar_id`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `pc_foreign` FOREIGN KEY (`cl_id`) REFERENCES `personal_classification` (`classification_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_class
-- ----------------------------
INSERT INTO `article_class` VALUES ('402881f25a82814c015a8330bd830008', '111', '402881f25a82814c015a8330bd820007');
INSERT INTO `article_class` VALUES ('402881f25a82814c015a8334a05c000f', '444', '402881f25a82814c015a8334a05c000e');
INSERT INTO `article_class` VALUES ('402881f25a8a68e1015a8a6968fb0001', '555', '402881f25a8a68e1015a8a6968e90000');
INSERT INTO `article_class` VALUES ('402881f25a8a68e1015a8a6968fb0002', '444', '402881f25a8a68e1015a8a6968e90000');
INSERT INTO `article_class` VALUES ('402881f25a8cfd00015a8cfdb6dd0002', '555', null);
INSERT INTO `article_class` VALUES ('402881f25a8cfd00015a8cfdb6de0003', '444', null);
INSERT INTO `article_class` VALUES ('402881f25a97325d015a97330c490000', '111', '402881f25a82814c015a83038b070002');
INSERT INTO `article_class` VALUES ('402881f25ab0dc06015ab0de39280002', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ab0dc06015ab0de39280003', '333', null);
INSERT INTO `article_class` VALUES ('402881f25ac80e96015ac81092fd0002', '111', '402881f25ac80e96015ac81092fb0001');
INSERT INTO `article_class` VALUES ('402881f25ac80e96015ac8112a1c0005', '111', '402881f25ac80e96015ac8112a1c0004');
INSERT INTO `article_class` VALUES ('402881f25ac80e96015ac81198610008', '111', '402881f25ac80e96015ac81198600007');
INSERT INTO `article_class` VALUES ('402881f25ac80e96015ac812022b000b', '111', '402881f25ac80e96015ac812022b000a');
INSERT INTO `article_class` VALUES ('402881f25acb8268015acb8896550004', '111', null);
INSERT INTO `article_class` VALUES ('402881f25acb990f015acb997f030000', '333', null);
INSERT INTO `article_class` VALUES ('402881f25acb990f015acb997f0a0001', null, null);
INSERT INTO `article_class` VALUES ('402881f25acfc4b6015acfcc86690003', '555', null);
INSERT INTO `article_class` VALUES ('402881f25acfc4b6015acfcc866a0004', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfc4b6015acfcd11e40007', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfd78b1c0001', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfd78b1c0002', '555', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfd9be430005', '555', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfd9be430006', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfdb8a150009', '555', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfdb8a15000a', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfdc1fa6000d', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfdc1fa6000e', '555', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfdfd1610011', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfe03a840014', '444', null);
INSERT INTO `article_class` VALUES ('402881f25acfcfb1015acfe03a840015', '555', null);
INSERT INTO `article_class` VALUES ('402881f25ae1f217015ae207617e0001', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ae1f217015ae2088f6d0003', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ae242a8015ae2449efc0001', '333', null);
INSERT INTO `article_class` VALUES ('402881f25ae242a8015ae2449efc0002', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ae242a8015ae24c58140005', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ae242a8015ae24c58140006', '333', null);
INSERT INTO `article_class` VALUES ('402881f25ae24ff0015ae2503d350001', '111', null);
INSERT INTO `article_class` VALUES ('402881f25ae24ff0015ae25072130004', '333', null);

-- ----------------------------
-- Table structure for attention
-- ----------------------------
DROP TABLE IF EXISTS `attention`;
CREATE TABLE `attention` (
  `attention_id` varchar(255) NOT NULL,
  `user` varchar(255) DEFAULT NULL,
  `follower` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`attention_id`),
  KEY `first_user` (`user`),
  KEY `second_user` (`follower`),
  CONSTRAINT `first_user` FOREIGN KEY (`user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `second_user` FOREIGN KEY (`follower`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of attention
-- ----------------------------
INSERT INTO `attention` VALUES ('111', '111', '402881f25a82814c015a83317e6e0009');
INSERT INTO `attention` VALUES ('333', '111', '222');
INSERT INTO `attention` VALUES ('402881f25ab2eb0a015ab33ccd0b0008', '402881f25a82814c015a83317e6e0009', '111');
INSERT INTO `attention` VALUES ('402881f25acb6263015acb68f9550001', '222', '111');

-- ----------------------------
-- Table structure for collection
-- ----------------------------
DROP TABLE IF EXISTS `collection`;
CREATE TABLE `collection` (
  `collection_id` varchar(255) NOT NULL,
  `user_id` varchar(255) DEFAULT NULL,
  `article_id` varchar(255) DEFAULT NULL,
  `collect_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`collection_id`),
  KEY `collection_article` (`article_id`),
  KEY `collection_user` (`user_id`),
  CONSTRAINT `collection_article` FOREIGN KEY (`article_id`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `collection_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of collection
-- ----------------------------
INSERT INTO `collection` VALUES ('402881f25a988172015a99203a950009', '402881f25a82814c015a83317e6e0009', '402881f25a82814c015a8330bd820007', '2017-03-10 13:05:10');
INSERT INTO `collection` VALUES ('402881f25a988172015a9921ae6f000b', '402881f25a82814c015a83317e6e0009', '402881f25a82814c015a83038b070002', '2017-03-10 13:05:14');
INSERT INTO `collection` VALUES ('402881f25acb990f015acbe0cd520005', '111', '402881f25a82814c015a8334a05c000e', '2017-03-14 08:13:12');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `comment_id` varchar(255) NOT NULL,
  `comment_user` varchar(255) DEFAULT NULL,
  `comment_article` varchar(255) DEFAULT NULL,
  `reply_user` varchar(255) DEFAULT NULL,
  `comment_content` varchar(2000) DEFAULT NULL,
  `comment_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `floor` int(11) DEFAULT NULL,
  PRIMARY KEY (`comment_id`),
  KEY `article_comment` (`comment_article`),
  KEY `c_user` (`comment_user`),
  KEY `r_user` (`reply_user`),
  CONSTRAINT `article_comment` FOREIGN KEY (`comment_article`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `c_user` FOREIGN KEY (`comment_user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION,
  CONSTRAINT `r_user` FOREIGN KEY (`reply_user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('402881f25acff4ea015ad108f1d3000a', '111', '402881f25a8a68e1015a8a6968e90000', null, '感觉好厉害的样子', '2017-03-15 08:15:09', '1');
INSERT INTO `comment` VALUES ('402881f25acff4ea015ad1099815000c', '111', '402881f25a8a68e1015a8a6968e90000', null, '评论评论评论', '2017-03-15 08:15:51', '2');
INSERT INTO `comment` VALUES ('402881f25acff4ea015ad109ab3c000e', '111', '402881f25a8a68e1015a8a6968e90000', null, '再评论', '2017-03-15 08:15:56', '3');
INSERT INTO `comment` VALUES ('402881f25acff4ea015ad109cb690010', '111', '402881f25a8a68e1015a8a6968e90000', null, '再三评论', '2017-03-15 08:16:04', '4');

-- ----------------------------
-- Table structure for dynamic
-- ----------------------------
DROP TABLE IF EXISTS `dynamic`;
CREATE TABLE `dynamic` (
  `dynamic_id` varchar(255) NOT NULL,
  `dynamic_user` varchar(255) DEFAULT NULL,
  `dynamic_article` varchar(255) DEFAULT NULL,
  `dynamic_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `dynamic_state` int(255) DEFAULT NULL,
  PRIMARY KEY (`dynamic_id`),
  KEY `dy_article` (`dynamic_article`),
  KEY `dy_user` (`dynamic_user`),
  CONSTRAINT `dy_article` FOREIGN KEY (`dynamic_article`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `dy_user` FOREIGN KEY (`dynamic_user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of dynamic
-- ----------------------------
INSERT INTO `dynamic` VALUES ('402881f25ac80e96015ac81093090003', '111', '402881f25ac80e96015ac81092fb0001', '2017-03-13 14:26:54', '0');
INSERT INTO `dynamic` VALUES ('402881f25ac80e96015ac8112a2b0006', '111', '402881f25ac80e96015ac8112a1c0004', '2017-03-13 14:27:33', '0');
INSERT INTO `dynamic` VALUES ('402881f25ac80e96015ac811986b0009', '111', '402881f25ac80e96015ac81198600007', '2017-03-13 14:28:01', '0');
INSERT INTO `dynamic` VALUES ('402881f25ac80e96015ac8120237000c', '111', '402881f25ac80e96015ac812022b000a', '2017-03-13 14:28:28', '0');
INSERT INTO `dynamic` VALUES ('402881f25acb6e3b015acb72e9d10003', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-14 06:13:10', '1');
INSERT INTO `dynamic` VALUES ('402881f25acb6e3b015acb74f3d90005', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-14 06:15:24', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad106f6660005', '111', '402881f25ac80e96015ac8112a1c0004', '2017-03-15 08:12:59', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad107170f0007', '111', '402881f25ac80e96015ac8112a1c0004', '2017-03-15 08:13:07', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad1076d7b0009', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-15 08:13:29', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad108f1d8000b', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-15 08:15:09', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad109981a000d', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-15 08:15:51', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad109ab41000f', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-15 08:15:56', '1');
INSERT INTO `dynamic` VALUES ('402881f25acff4ea015ad109cb700011', '111', '402881f25a8a68e1015a8a6968e90000', '2017-03-15 08:16:04', '1');

-- ----------------------------
-- Table structure for education
-- ----------------------------
DROP TABLE IF EXISTS `education`;
CREATE TABLE `education` (
  `education_id` varchar(255) NOT NULL,
  `userid` varchar(255) DEFAULT NULL,
  `start_date` date DEFAULT NULL,
  `end_date` date DEFAULT NULL,
  `education` varchar(255) DEFAULT NULL,
  `school` varchar(255) DEFAULT NULL,
  `professional` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`education_id`),
  KEY `education_user` (`userid`),
  CONSTRAINT `education_user` FOREIGN KEY (`userid`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of education
-- ----------------------------
INSERT INTO `education` VALUES ('402881f25aa97072015aa970abe50000', '111', '2011-01-27', '2012-01-27', '本科', '安信工', '计算机');
INSERT INTO `education` VALUES ('402881f25aab7b99015aab9b27d60001', '111', '2017-03-06', '2017-03-06', '本科', '不明', '计算机');
INSERT INTO `education` VALUES ('402881f25ac86d44015ac86d7c1b0000', '111', '2017-03-12', '2017-03-12', '硕士', '合肥工业大学', '计算机');

-- ----------------------------
-- Table structure for letter
-- ----------------------------
DROP TABLE IF EXISTS `letter`;
CREATE TABLE `letter` (
  `letter_id` varchar(255) NOT NULL,
  `send_user` varchar(255) DEFAULT NULL,
  `receive_user` varchar(255) DEFAULT NULL,
  `send_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `letter_content` varchar(1000) DEFAULT NULL,
  PRIMARY KEY (`letter_id`),
  KEY `send_user` (`send_user`),
  KEY `receive_user` (`receive_user`),
  CONSTRAINT `receive_user` FOREIGN KEY (`receive_user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `send_user` FOREIGN KEY (`send_user`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of letter
-- ----------------------------
INSERT INTO `letter` VALUES ('402881f25ad4eb95015ad4f253050001', '111', '402881f25a82814c015a83317e6e0009', '2017-03-16 02:28:55', '再来一条');
INSERT INTO `letter` VALUES ('402881f25ad4eb95015ad4f31e3b0003', '402881f25a82814c015a83317e6e0009', '111', '2017-03-16 02:29:47', '我也给你发一条');
INSERT INTO `letter` VALUES ('402881f25ad4eb95015ad4f4e4480004', '402881f25a82814c015a83317e6e0009', '111', '2017-03-16 02:31:43', '再来一条');
INSERT INTO `letter` VALUES ('402881f25ad4eb95015ad4f4fcf00005', '402881f25a82814c015a83317e6e0009', '111', '2017-03-16 02:31:50', '还来一条');
INSERT INTO `letter` VALUES ('402881f25ad58171015ad5cd531d0000', '111', '402881f25a82814c015a83317e6e0009', '2017-03-16 06:28:08', '你真闲');
INSERT INTO `letter` VALUES ('402881f25ad58171015ad5cfd2770001', '111', '402881f25a82814c015a83317e6e0009', '2017-03-16 06:30:51', '你傻啊');
INSERT INTO `letter` VALUES ('402881f25ad58171015ad5d092ed0002', '111', '402881f25a82814c015a83317e6e0009', '2017-03-16 06:31:41', '傻吊');

-- ----------------------------
-- Table structure for login_log
-- ----------------------------
DROP TABLE IF EXISTS `login_log`;
CREATE TABLE `login_log` (
  `login_id` varchar(255) NOT NULL,
  `login_userid` varchar(255) DEFAULT NULL,
  `login_username` varchar(255) DEFAULT NULL,
  `login_date` datetime DEFAULT NULL,
  `login_ip` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`login_id`),
  KEY `login_user` (`login_userid`),
  CONSTRAINT `login_user` FOREIGN KEY (`login_userid`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of login_log
-- ----------------------------
INSERT INTO `login_log` VALUES ('402881f25a794e44015a794e470f0000', null, null, '2017-02-26 00:00:00', null);
INSERT INTO `login_log` VALUES ('402881f25a796f92015a796fce9e0000', null, 'dddd', '2017-02-26 00:00:00', null);
INSERT INTO `login_log` VALUES ('402881f25a7d1ba2015a7d1c2ac80000', null, 'dddd', '2017-02-27 01:08:02', null);
INSERT INTO `login_log` VALUES ('402881f25a7d44a8015a7d45fe280000', null, 'dddd', '2017-02-27 01:53:43', null);
INSERT INTO `login_log` VALUES ('402881f25a7d967d015a7e1255420002', null, 'dddd', '2017-02-27 05:36:55', null);
INSERT INTO `login_log` VALUES ('402881f25a7e24a8015a7e24cc6b0000', null, 'dddd', '2017-02-27 05:57:05', null);
INSERT INTO `login_log` VALUES ('402881f25a7e37c0015a7e385e3b0000', null, 'dddd', '2017-02-27 06:18:28', null);
INSERT INTO `login_log` VALUES ('402881f25a7e4e97015a7e5142e60000', null, 'dddd', '2017-02-27 06:45:39', null);
INSERT INTO `login_log` VALUES ('402881f25a7e714f015a7e71746f0000', null, 'dddd', '2017-02-27 07:20:49', null);
INSERT INTO `login_log` VALUES ('402881f25a7eb1b7015a7eb1f87c0000', null, 'dddd', '2017-02-27 08:31:17', null);
INSERT INTO `login_log` VALUES ('402881f25a7f51f1015a7f52464a0000', null, 'dddd', '2017-02-27 11:26:23', null);
INSERT INTO `login_log` VALUES ('402881f25a7f5ca1015a7f5cda320000', null, 'dddd', '2017-02-27 11:37:56', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a8281ac7c0000', null, 'dddd', '2017-02-28 02:17:01', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a82fdeec00001', null, 'dddd', '2017-02-28 04:32:44', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a83268baa0004', null, 'dddd', '2017-02-28 05:17:06', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a832a02170005', null, 'dddd', '2017-02-28 05:20:53', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a832a31280006', null, 'dddd', '2017-02-28 05:21:05', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a8331a266000a', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-02-28 05:29:13', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a833230d5000b', null, 'dddd', '2017-02-28 05:29:49', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a83329d91000c', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-02-28 05:30:17', null);
INSERT INTO `login_log` VALUES ('402881f25a82814c015a83342629000d', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-02-28 05:31:57', null);
INSERT INTO `login_log` VALUES ('402881f25a8410bb015a8460036b0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-02-28 10:59:29', null);
INSERT INTO `login_log` VALUES ('402881f25a84ca34015a84e269020000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-02-28 13:21:55', null);
INSERT INTO `login_log` VALUES ('402881f25a8a5c74015a8a6293810000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-01 15:00:01', null);
INSERT INTO `login_log` VALUES ('402881f25a8cfd00015a8cfd1ac30000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-02 03:08:02', null);
INSERT INTO `login_log` VALUES ('402881f25a8d0bcc015a8dfc085c0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-02 07:46:29', null);
INSERT INTO `login_log` VALUES ('402881f25a8eff48015a8f0caadd0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-02 12:44:16', null);
INSERT INTO `login_log` VALUES ('402881f25a937f14015a937f88dc0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-03 09:28:13', null);
INSERT INTO `login_log` VALUES ('402881f25a9439a6015a94600bfe0000', null, 'dddd', '2017-03-03 13:33:27', null);
INSERT INTO `login_log` VALUES ('402881f25a96f7b9015a971fc85d0000', null, 'dddd', '2017-03-04 02:22:07', null);
INSERT INTO `login_log` VALUES ('402881f25a972bae015a972be00e0000', null, 'dddd', '2017-03-04 02:35:19', null);
INSERT INTO `login_log` VALUES ('402881f25a97dcdd015a98160bc70000', null, 'dddd', '2017-03-04 06:51:06', null);
INSERT INTO `login_log` VALUES ('402881f25a97dcdd015a982ccbad0001', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-04 07:15:57', null);
INSERT INTO `login_log` VALUES ('402881f25a985c25015a985c6d360000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-04 08:07:59', null);
INSERT INTO `login_log` VALUES ('402881f25a985c25015a987d11a80002', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-04 08:43:38', null);
INSERT INTO `login_log` VALUES ('402881f25a988172015a991caa720007', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-04 11:37:57', null);
INSERT INTO `login_log` VALUES ('402881f25a988172015a998cf0b4000c', null, 'dddd', '2017-03-04 13:40:35', null);
INSERT INTO `login_log` VALUES ('402881f25a99a6df015a99a71dcc0000', null, 'dddd', '2017-03-04 14:09:11', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25a99b546015a99b573430000', null, 'dddd', '2017-03-04 14:24:50', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25a9cd73f015a9cd8e46d0000', null, 'dddd', '2017-03-05 05:02:24', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa1654b015aa166527f0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-06 02:15:22', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa19438015aa19498600000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-06 03:05:55', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa1f869015aa1f8d3bf0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-06 04:55:23', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa1f869015aa24f5af20001', null, 'dddd', '2017-03-06 06:29:54', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa1f869015aa2ae3f730002', null, 'dddd', '2017-03-06 08:13:33', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa1f869015aa2ecb4fa0003', null, 'dddd', '2017-03-06 09:21:46', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa75bba015aa75de4730000', null, 'dddd', '2017-03-07 06:03:53', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa87a93015aa88d87620000', null, 'dddd', '2017-03-07 11:35:32', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa8bd99015aa8c9af5c0000', '111', 'dddd', '2017-03-07 12:41:14', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa8bd99015aa9060cb60001', '111', 'dddd', '2017-03-07 13:47:10', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aa96b90015aa96bc7510000', '111', 'dddd', '2017-03-07 15:38:17', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aab7b99015aab7e87de0000', '111', 'dddd', '2017-03-08 01:18:01', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aac3d10015aac76b4ea0000', '111', 'dddd', '2017-03-08 05:49:05', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aad013f015aad01a4ad0000', '111', 'dddd', '2017-03-08 08:20:50', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25aad013f015aad6b77c00001', '111', 'dddd', '2017-03-08 10:16:26', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab0b399015ab0b4041c0000', '111', 'dddd', '2017-03-09 01:34:32', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab0d89b015ab0d921f60000', '111', 'dddd', '2017-03-09 02:15:04', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab0dc06015ab0de00500000', '111', 'dddd', '2017-03-09 02:20:24', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab1a5f7015ab1a61d3d0000', '111', 'dddd', '2017-03-09 05:58:58', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab1a5f7015ab1bc5e4f0001', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-09 06:23:17', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2c092015ab2c0d5b50000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-09 11:07:46', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2c70d015ab2cacfca0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-09 11:18:40', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2ce61015ab2cf7faf0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-09 11:23:47', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2ce61015ab2d11c0a0001', '111', 'dddd', '2017-03-09 11:25:33', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2d711015ab2dab4050000', '111', 'dddd', '2017-03-09 11:36:02', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2eb0a015ab2f2e41d0004', '111', 'dddd', '2017-03-09 12:02:27', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab2eb0a015ab32365540006', '111', 'dddd', '2017-03-09 12:55:26', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab37c6d015ab3944d4d0000', '111', 'dddd', '2017-03-09 14:58:45', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab641a2015ab645259a0000', '111', 'dddd', '2017-03-10 03:31:09', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab6981c015ab6ac786e0000', '111', 'dddd', '2017-03-10 05:24:01', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab71560015ab71646760000', '111', 'dddd', '2017-03-10 07:19:35', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab75acb015ab7a01a020000', '111', 'dddd', '2017-03-10 09:50:07', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab75acb015ab7bcb1460001', '111', 'dddd', '2017-03-10 10:21:21', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab828c4015ab8294bce0000', '111', 'dddd', '2017-03-10 12:19:59', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab8500e015ab851e9180000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-10 13:04:20', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab8500e015ab88b49620003', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-10 14:07:00', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab8cd91015ab8cdfef90000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-10 15:19:52', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab8d347015ab8d3828d0000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-10 15:25:54', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ab8de13015ab8dec49e0000', '111', 'dddd', '2017-03-10 15:38:11', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25abdef4c015abdf141d80000', '111', 'dddd', '2017-03-11 15:16:29', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25abdef4c015abdf183880001', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-11 15:16:46', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ac80d3d015ac80da7720000', '111', 'dddd', '2017-03-13 14:23:42', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ac80e96015ac80f25800000', '111', 'dddd', '2017-03-13 14:25:20', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ac80e96015ac81c0410000d', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-13 14:39:24', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ac80e96015ac82fe5b5000e', '111', 'dddd', '2017-03-13 15:01:07', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acb6263015acb62c4810000', '111', 'dddd', '2017-03-14 05:55:32', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acb990f015acbc6315f0003', '111', 'dddd', '2017-03-14 07:44:08', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acf94a9015acfa006a90000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 01:40:56', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb282850000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:01:07', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb502e90001', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:03:51', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb526140002', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:04:00', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb5738d0003', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:04:20', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb597b10004', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:04:29', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfb73ae00005', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:06:16', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfb230015acfc33f260006', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:19:24', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfc4b6015acfc4ddb20000', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:21:10', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acfc4b6015acfc892fe0001', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-15 02:25:13', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acff4ea015ad01430230000', '111', 'dddd', '2017-03-15 03:47:48', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acff4ea015ad014489f0001', '111', 'dddd', '2017-03-15 03:47:55', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acff4ea015ad0b4cdf50002', '111', 'dddd', '2017-03-15 06:43:15', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25acff4ea015ad105989d0003', '111', 'dddd', '2017-03-15 08:11:29', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad14e71015ad14e98390000', '111', 'dddd', '2017-03-15 09:31:13', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad22314015ad238bc6b0000', '111', 'dddd', '2017-03-15 13:46:58', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad22314015ad2651e110001', '111', 'dddd', '2017-03-15 14:35:27', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad4c7e1015ad4cd72fd0000', '111', 'dddd', '2017-03-16 01:48:39', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad4eb95015ad4f2d5ae0002', '402881f25a82814c015a83317e6e0009', 'aaaaa', '2017-03-16 02:29:29', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad4eb95015ad4f53a150006', '111', 'dddd', '2017-03-16 02:32:05', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad4eb95015ad51931f20007', '111', 'dddd', '2017-03-16 03:11:23', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad58171015ad60443d90003', '111', 'dddd', '2017-03-16 07:28:08', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad58171015ad6222bbf0004', '111', 'dddd', '2017-03-16 08:00:48', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad58171015ad6b931960005', '111', 'dddd', '2017-03-16 10:45:45', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ad58171015ad770ef530006', '111', 'dddd', '2017-03-16 14:06:27', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25adf28e8015adf2932ea0000', '111', 'dddd', '2017-03-18 02:05:04', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25adf28e8015adf603c210001', '111', 'dddd', '2017-03-18 03:05:10', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25adfa12a015adfa19a430000', '111', 'dddddd', '2017-03-18 04:16:34', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25adfad98015adfadd70b0000', '111', 'jiangyinghao', '2017-03-18 04:29:56', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25adfad98015adfae449e0001', '111', 'jiang', '2017-03-18 04:30:24', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ae0b45a015ae0c4873e0000', '111', 'jiang', '2017-03-18 09:34:20', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ae0ee57015ae0f7534b0000', '111', 'jiang', '2017-03-18 10:29:50', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ae0ee57015ae199bd130001', '111', 'jiang', '2017-03-18 13:27:13', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('402881f25ae2291c015ae229d5c00003', '111', 'jiang', '2017-03-18 16:04:37', '0:0:0:0:0:0:0:1');
INSERT INTO `login_log` VALUES ('ff8080815a7d6c19015a7d6ca1a30000', null, 'dddd', '2017-02-27 02:35:56', null);

-- ----------------------------
-- Table structure for option_log
-- ----------------------------
DROP TABLE IF EXISTS `option_log`;
CREATE TABLE `option_log` (
  `option_id` varchar(255) NOT NULL,
  `option_userid` varchar(255) DEFAULT NULL,
  `option_username` varchar(255) DEFAULT NULL,
  `option_date` datetime DEFAULT NULL,
  `option_method` varchar(255) DEFAULT NULL,
  `option_class` varchar(255) DEFAULT NULL,
  `option_message` varchar(1000) DEFAULT NULL,
  PRIMARY KEY (`option_id`),
  KEY `option_user` (`option_userid`),
  CONSTRAINT `option_user` FOREIGN KEY (`option_userid`) REFERENCES `user` (`user_id`) ON DELETE SET NULL ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of option_log
-- ----------------------------
INSERT INTO `option_log` VALUES ('00a93099-8713-4cdf-86de-5d3f6d4ad8bf', null, 'dddd', '2017-02-24 11:22:01', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('030a947c-a3a7-456d-8ae2-51e4f96362a2', null, 'dddd', '2017-02-24 11:16:22', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('048ccc1f-a069-498c-a5ff-0e2e4bdfe8f3', null, 'dddd', '2017-02-24 12:14:47', 'getUserName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('0aef30b3-659c-4b28-8e14-1c4d2176f590', null, 'dddd', '2017-02-22 21:46:28', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('0e0de65d-e009-4b96-bd2e-40a4f29afcae', null, 'dddd', '2017-02-24 11:44:29', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('10a53c8e-72e6-4a27-a29b-40f964ee5111', null, 'dddd', '2017-02-24 11:14:37', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('11f3c5d8-f1e6-42d1-828b-f015fec61a17', null, 'dddd', '2017-02-24 11:40:38', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('1280dc08-aa94-4e0b-8f81-7d0f8528798f', null, 'dddd', '2017-02-22 22:45:31', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('13b53dde-b1f0-46e8-902e-aa7d64bb1eff', null, 'dddd', '2017-02-24 11:53:56', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('14befeee-e404-4e6e-b90e-37221d7d679d', null, 'dddd', '2017-02-24 11:34:10', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('16c6e8be-9054-4f0c-8480-9a051806481a', null, 'dddd', '2017-02-24 11:39:21', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('17c4d1dc-3abf-4d7b-a5fb-fb5609aace12', null, 'dddd', '2017-02-24 11:32:28', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('18b08c30-02eb-4b25-91b1-562bf747ba1e', null, 'dddd', '2017-02-24 12:35:11', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('1f323ec5-1e20-4897-a008-26dfbf3b4b2f', null, 'dddd', '2017-02-24 12:06:59', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('2013995c-e0bb-4185-9e96-afb26defe56d', null, 'dddd', '2017-02-22 18:39:32', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('268d0ebf-259f-4149-bf4f-74e22fb351a6', null, 'dddd', '2017-02-23 19:16:50', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('2a37d2e6-7dfa-4599-aebc-f3553494f1e9', null, 'dddd', '2017-02-24 11:58:55', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('2aa4aa55-8361-4f46-af63-995a319da37b', null, 'dddd', '2017-02-24 12:22:55', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('2bc687d5-6ba7-4bdc-ad88-0ee5771772a7', null, 'dddd', '2017-02-24 11:35:55', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('2d0aace4-ead4-447e-8f2f-ba47e644a494', null, 'dddd', '2017-02-22 18:33:06', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('2d6c42fb-4fdd-4739-a012-6fd8ff26a467', null, 'dddd', '2017-02-22 18:41:04', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('2df84174-6b53-4645-a5a4-5e7cbea9c7dc', null, 'dddd', '2017-02-24 11:11:40', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('3257b127-3a11-4bf3-8690-b96d4b144736', null, 'dddd', '2017-02-24 11:36:56', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('37102333-84bf-4287-9d6e-a88c98385956', null, 'dddd', '2017-02-24 11:18:36', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('39e3c3dc-434c-403e-a237-86733272f241', null, 'dddd', '2017-02-22 21:45:41', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('3a4065ed-8fad-41b0-92ba-69aa27242254', null, 'dddd', '2017-02-24 11:32:21', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('3b061f7a-bda7-4c8d-845e-27e2321737db', null, 'dddd', '2017-02-24 12:06:59', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('3b42a17d-b716-4171-96d2-fd8dbc8df264', null, 'dddd', '2017-02-22 21:50:46', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('3f203d2b-e01c-4d06-8ba5-56d6d272028e', null, 'dddd', '2017-02-22 22:45:00', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('4410e490-8698-4da1-9bbc-b8f0b2923ae7', null, 'dddd', '2017-02-24 11:34:04', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('4dc56ec3-a2c0-4510-9aa6-7ddc75cfe561', null, 'dddd', '2017-02-24 11:50:40', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('4e8c62ae-de97-4d17-9dfb-021d66d88234', null, 'dddd', '2017-02-24 11:19:37', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('4eb416e9-ccf5-4307-983d-c3330fc3535f', null, 'dddd', '2017-02-22 22:45:00', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('522b7bcf-c9c2-4766-ae04-453167702c0c', null, 'dddd', '2017-02-24 11:42:15', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('53b60360-25aa-416e-9f4e-492368200e0c', null, 'dddd', '2017-02-24 12:05:42', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('54084ab9-5682-4203-b1ba-74ac1b788545', null, 'dddd', '2017-02-24 12:01:41', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('551518a4-2513-4dca-8f68-b05c2fc02bbb', null, 'dddd', '2017-02-24 11:40:29', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('5710b765-33c6-40a7-ae80-2f019f1ba4a9', null, 'dddd', '2017-02-22 18:43:40', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('597530dd-eb40-423c-a44e-2b559f7612f1', null, 'dddd', '2017-02-23 19:21:12', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('5bfb9e0b-32bc-44eb-9847-05f5351948c6', null, 'dddd', '2017-02-24 11:23:23', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('5f148b6d-fcc0-42ce-b4a9-5ae8e4649341', null, 'dddd', '2017-02-24 11:12:56', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('60dce3dd-05b9-4dc8-a35d-3814e8c5aacc', null, 'dddd', '2017-02-24 11:19:47', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('61256783-730a-42ff-af98-fc1d7772bfeb', null, 'dddd', '2017-02-22 22:44:40', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('636ddb3a-b504-4ffa-8c2a-d22a14998b1c', null, 'dddd', '2017-02-23 20:27:34', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('63f8dea6-2c27-403e-aa75-cded8f3e00f1', null, 'dddd', '2017-02-24 12:12:05', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('65ae7300-8421-41c8-8b0f-ff2ec290c4a0', null, 'dddd', '2017-02-22 22:48:55', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('67444abf-020c-4aa0-a8d6-c87c2a8b0562', null, 'dddd', '2017-02-22 22:08:05', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('6ca05d35-d2d0-46ca-899f-bcdcf37c7f1e', null, 'dddd', '2017-02-23 20:03:20', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('6dc1cd70-0013-4caa-adc8-091604d818f6', null, 'dddd', '2017-02-24 11:13:59', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('707d9368-7d9e-4e01-a194-b8213bbd5f76', null, 'dddd', '2017-02-24 11:17:01', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('73cc949c-a594-4a59-a12e-56822de359ef', null, 'dddd', '2017-02-23 18:19:24', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('761b1e9c-4231-408e-8878-ec0119f913a2', null, 'dddd', '2017-02-24 11:48:40', 'getById', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('767f4cf1-3115-4a9a-b83b-64891b4c68dd', null, 'dddd', '2017-02-22 18:34:58', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('77ba89ae-df71-402d-8cd8-33444870c3f6', null, 'dddd', '2017-02-22 18:35:16', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('796047ac-7b62-451e-8833-1c0c6bfb4d59', null, 'dddd', '2017-02-22 22:36:18', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('79891265-c4fa-43bf-8882-ad2ec4824514', null, 'dddd', '2017-02-22 22:45:41', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('7d25db2c-f81b-4c38-8863-1ffe681d2e3c', null, 'dddd', '2017-02-23 18:09:55', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('7dafdda5-77fd-40bf-9e93-2b134577fd4a', null, 'dddd', '2017-02-23 20:28:03', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('7e3d4035-c63d-47c4-a081-0fd39495e9c6', null, 'dddd', '2017-02-24 11:36:25', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('82714fc2-2c1b-4e5e-8161-e96a2877b5b6', null, 'dddd', '2017-02-24 12:37:27', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('834ded67-f391-4ea0-b32d-4a6e4bd07b76', null, 'dddd', '2017-02-24 11:36:46', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('872ede53-d084-4357-b334-0d71903d6585', null, 'dddd', '2017-02-22 18:40:28', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('89d5e4e6-ca75-4e7b-96e4-17b8ef1ea9a9', null, 'dddd', '2017-02-24 11:22:54', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('8a2ff6fe-fc7f-4c31-8e26-061133706cd7', null, 'dddd', '2017-02-24 11:45:59', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('96196c94-e288-4e00-8b49-5be7460d6e5e', null, 'dddd', '2017-02-24 12:12:05', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('98653fd0-23e8-4e2b-b48b-ab440956f358', null, 'dddd', '2017-02-24 11:49:27', 'getById', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('99d1fb14-1d54-47eb-8fdb-fa1ac4d57890', null, 'dddd', '2017-02-24 11:10:17', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('9ab54e41-e0b4-41c3-8441-a5af32b6f8b8', null, 'dddd', '2017-02-24 12:14:48', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('9bdfe56b-796c-4c6f-9208-9eda93f7ea4d', null, 'dddd', '2017-02-24 11:09:22', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('9ea4b2f3-5401-42a2-b7c8-efb68fddc996', null, 'dddd', '2017-02-24 12:17:04', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('9eefd633-1f9d-42ff-9a58-45efa788362a', null, 'dddd', '2017-02-24 11:50:08', 'getById', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('a340eb3e-022a-4ea5-b9c2-2f44505e8cf9', null, 'dddd', '2017-02-23 13:46:01', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b11e01e0-7908-487f-8135-11413710c0fe', null, 'dddd', '2017-02-22 22:15:17', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b4ce8f31-e9ff-4854-9abc-353ff2f8ff9f', null, 'dddd', '2017-02-22 18:43:37', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b50847a8-34c8-4c9a-a2aa-950991dd8396', null, 'dddd', '2017-02-24 11:36:53', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b6c205f9-624d-4340-8642-2f94e7da7d8c', null, 'dddd', '2017-02-24 12:12:31', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('b7257f92-8326-4b4e-aa62-5f9938404c44', null, 'dddd', '2017-02-22 22:35:55', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b74376b7-b983-4f20-a0d4-7813937bb4fa', null, 'dddd', '2017-02-24 11:47:07', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('b9e87fa5-e246-4187-904e-e67e77b94530', null, 'dddd', '2017-02-24 11:50:08', 'getById', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('c0c41ee4-8258-45ac-97cb-ce6511f55966', null, 'dddd', '2017-02-23 11:54:00', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('c38ed792-7b2b-49cd-84d7-d0ee034c37ee', null, 'dddd', '2017-02-22 18:39:45', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('c7a40988-2bc4-4d40-bbf2-a9b1a72556c6', null, 'dddd', '2017-02-22 22:35:42', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('c7b172c4-94e8-4090-ab4f-51ba10154c72', null, 'dddd', '2017-02-24 11:07:58', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('c7d45b6c-a5b6-4506-a333-dab6756236ee', null, 'dddd', '2017-02-22 22:15:40', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('cafdb67c-22a9-4181-aafe-aead71902687', null, 'dddd', '2017-02-23 18:57:31', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('cdfa7765-535f-4ec8-9ead-aa9abebdb28b', null, 'dddd', '2017-02-24 11:47:58', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('cf7f9530-e8e3-41e9-8ed7-a0f3171a7160', null, 'dddd', '2017-02-22 22:50:05', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('de07221e-c9de-48bd-ab61-f33f377a32f8', null, 'dddd', '2017-02-24 11:24:58', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('dee11775-893c-45e6-988b-404d77c97900', null, 'dddd', '2017-02-24 12:05:42', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');
INSERT INTO `option_log` VALUES ('e4032763-38d3-432d-a5c6-499ef57d92d5', null, 'dddd', '2017-02-22 22:39:12', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('e4d64724-f69a-45b2-959b-00726651cc9a', null, 'dddd', '2017-02-22 18:34:46', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('e6b7b481-82f5-4bfd-8703-62f34667cf80', null, 'dddd', '2017-02-22 23:07:57', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('e73ec1e7-a483-4ec7-89a0-f84563686d71', null, 'dddd', '2017-02-24 11:12:07', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('e7f42ccf-6158-40fa-8cc8-7bbeb0872ab1', null, 'dddd', '2017-02-24 11:16:55', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('ea9d522d-718e-4409-b78a-a20ae0941292', null, 'dddd', '2017-02-24 11:11:16', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('ed152912-c3a5-4241-a4d0-2eeb4d21d193', null, 'dddd', '2017-02-22 22:44:59', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('edd03fc0-0560-4da0-88a8-5f5d71e2aebf', null, 'dddd', '2017-02-22 23:08:26', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('ee4a03da-cf21-4d3d-9943-3474d74e741a', null, 'dddd', '2017-02-24 11:18:29', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('f0a9a007-801e-4a56-badd-918b0187db1b', null, 'dddd', '2017-02-22 22:44:42', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('f304a004-18ab-4367-a9fb-b82e8b13fd77', null, 'dddd', '2017-02-24 11:36:57', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('f41ec4c1-dc0b-4e5b-9cfc-c204decafb00', null, 'dddd', '2017-02-24 11:01:16', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('f61dbf59-8bf9-448a-89c6-f8e515b11295', null, 'dddd', '2017-02-22 22:16:46', 'save', 'class com.jyh.dao.impl.UserDaoImpl', '测试');
INSERT INTO `option_log` VALUES ('fe1e4e7c-a92d-4c1f-b32a-b6a99535c6e2', null, 'dddd', '2017-02-24 12:26:21', 'getUserByName', 'class com.jyh.dao.impl.UserDaoImpl', '');

-- ----------------------------
-- Table structure for personal_classification
-- ----------------------------
DROP TABLE IF EXISTS `personal_classification`;
CREATE TABLE `personal_classification` (
  `classification_id` varchar(255) NOT NULL,
  `classification_name` varchar(255) DEFAULT NULL,
  `user_id` varchar(255) DEFAULT NULL,
  `default_setting` int(11) DEFAULT NULL,
  PRIMARY KEY (`classification_id`),
  KEY `user_class` (`user_id`),
  CONSTRAINT `user_class` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE SET NULL ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of personal_classification
-- ----------------------------
INSERT INTO `personal_classification` VALUES ('111', 'java', '111', '0');
INSERT INTO `personal_classification` VALUES ('333', 'mybatis', '111', null);
INSERT INTO `personal_classification` VALUES ('444', 'java', '402881f25a82814c015a83317e6e0009', '0');
INSERT INTO `personal_classification` VALUES ('555', 'spring', '402881f25a82814c015a83317e6e0009', null);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` varchar(255) NOT NULL,
  `user_name` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `user_nickname` varchar(255) DEFAULT NULL,
  `user_truename` varchar(255) DEFAULT NULL,
  `user_img` varchar(255) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `gender` int(11) DEFAULT NULL,
  `address` varchar(255) DEFAULT NULL,
  `industry` varchar(255) DEFAULT NULL,
  `career` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `telphone` varchar(255) DEFAULT NULL,
  `qq` varchar(255) DEFAULT NULL,
  `wechat` varchar(255) DEFAULT NULL,
  `know_field` varchar(1000) DEFAULT NULL,
  `professional_skill` varchar(1000) DEFAULT NULL,
  `province` varchar(255) DEFAULT NULL,
  `city` varchar(255) DEFAULT NULL,
  `introduction` varchar(1000) DEFAULT NULL,
  `visited_num` int(11) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('111', 'jiang', '8752a82e5bca727b7985145b70e126df', 'OverrideRe', '江英豪', 'upload/userImg/de1e602d-5836-48ca-9ad7-7f54b0dc6869.png', '1995-04-09', '1', '安徽省枞阳县', '互联网', 'java开发', '727691961@qq.com', '15551209682', '727691961', 'yhjiangRe', 'java,mysql', 'java,数据结构', '安徽', '安庆市', '我就是我，不一样的烟火！', '27');
INSERT INTO `user` VALUES ('222', 'bbb', '11ddbaf3386aea1f2974eee984542152', 'bbb', 'bbb', 'blog/images/user.jpg', null, null, null, null, null, null, null, null, null, null, null, null, null, null, '7');
INSERT INTO `user` VALUES ('402881f25a82814c015a83317e6e0009', 'aaaaa', '594f803b380a41396ed63dca39503542', 'aaaaa', null, 'blog/data/DefaultPicture/1/10.jpg', null, null, null, null, null, '15551209682@163.com', null, null, null, null, null, null, null, '', '107');

-- ----------------------------
-- Table structure for work
-- ----------------------------
DROP TABLE IF EXISTS `work`;
CREATE TABLE `work` (
  `work_id` varchar(255) NOT NULL,
  `userid` varchar(255) DEFAULT NULL,
  `start_date` date DEFAULT NULL,
  `end_date` date DEFAULT NULL,
  `company` varchar(255) DEFAULT NULL,
  `position` varchar(255) DEFAULT NULL,
  `briefing` varchar(1000) DEFAULT NULL,
  PRIMARY KEY (`work_id`),
  KEY `work_user` (`userid`),
  CONSTRAINT `work_user` FOREIGN KEY (`userid`) REFERENCES `user` (`user_id`) ON DELETE SET NULL ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of work
-- ----------------------------
INSERT INTO `work` VALUES ('402881f25aad90c5015aad9126f20000', '111', '2017-03-07', '2017-03-07', '皆成', 'java工程师', '无');
INSERT INTO `work` VALUES ('402881f25aad90c5015aad94db4e0001', '111', '2017-03-06', '2017-03-06', '讯飞', '测试', '蛮好的');
SET FOREIGN_KEY_CHECKS=1;
